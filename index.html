<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Mapa de Clientes - Geolocalização</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" >

    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" >

    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --danger-hover: #dc2626;
            --bg-primary: #ffffff;
            --bg-secondary: #f3f4f6;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --border: #e5e7eb;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        .dark {
            --bg-primary: #1f2937;
            --bg-secondary: #111827;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --border: #374151;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            /* Safe area for devices with notch */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .app-container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background: var(--bg-primary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .sidebar-header {
            padding: 20px;
            background: linear-gradient(135deg, var(--primary) 0%, #3b82f6 100%);
            color: white;
        }

        .sidebar-header h1 {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 13px;
            opacity: 0.9;
        }

        /* Search Box */
        .search-container {
            padding: 15px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
        }

        .search-box {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-icon {
            position: absolute;
            left: 12px;
            color: var(--text-secondary);
            font-size: 16px;
            pointer-events: none;
        }

        .search-input {
            width: 100%;
            padding: 10px 40px 10px 38px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-primary);
        }

        .search-input::placeholder {
            color: var(--text-secondary);
        }

        .clear-search {
            position: absolute;
            right: 10px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            display: none;
            font-size: 18px;
            line-height: 1;
            transition: color 0.2s;
        }

        .clear-search:hover {
            color: var(--text-primary);
        }

        .clear-search.visible {
            display: block;
        }

        .search-results-info {
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
        }

        .upload-section {
            padding: 15px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
        }

        .upload-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .upload-input {
            display: none;
        }

        .upload-status {
            margin-top: 8px;
            font-size: 12px;
            text-align: center;
            color: var(--text-secondary);
        }

        .upload-status.success {
            color: var(--success);
            font-weight: 600;
        }

        .upload-status.warning {
            color: var(--warning);
            font-weight: 600;
        }

        .upload-status.error {
            color: var(--danger);
            font-weight: 600;
        }

        .clients-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .client-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .client-item:hover {
            border-color: var(--primary);
        }

        .client-item.hidden {
            display: none;
        }

        .client-item.highlight {
            border-color: var(--primary);
            background: linear-gradient(90deg, var(--bg-secondary) 0%, rgba(37, 99, 235, 0.05) 100%);
        }

        .highlight-text {
            background: rgba(37, 99, 235, 0.2);
            padding: 1px 3px;
            border-radius: 3px;
            font-weight: 600;
        }

        .client-name {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .client-address {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .client-coords {
            font-size: 11px;
            color: var(--text-secondary);
            font-family: monospace;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Map Container */
        #map {
            flex: 1;
            height: 100vh;
        }

        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--success);
            color: white;
            border: none;
            box-shadow: 0 4px 12px var(--shadow);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: 300;
            line-height: 1;
            transition: all 0.3s;
            z-index: 1000;
            -webkit-user-select: none;
            user-select: none;
        }

        .fab:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 6px 20px var(--shadow);
        }

        .fab:active {
            transform: translateX(-50%) scale(0.95);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--bg-primary);
            border: none;
            box-shadow: 0 2px 8px var(--shadow);
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            transition: all 0.3s ease;
        }

        .menu-toggle:active {
            transform: translateX(-50%) scale(0.95);
        }

        .menu-toggle svg {
            width: 24px;
            height: 24px;
            fill: var(--text-primary);
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000; /* Maior que admin-panel (9999) */
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s;
        }

        .modal-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: var(--bg-primary);
            border-radius: 12px;
            width: 90%;
            max-width: 450px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .modal-header h2 {
            font-size: 20px;
            color: var(--text-primary);
        }

        .modal-body {
            padding: 20px;
        }

        .camera-section {
            margin-bottom: 20px;
            text-align: center;
        }

        .scan-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s;
        }

        .scan-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .scan-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .camera-preview {
            margin-top: 16px;
            display: none;
            position: relative;
            max-height: 400px;
            overflow: hidden;
        }

        .camera-preview.active {
            display: block;
        }

        .camera-preview video,
        .camera-preview canvas {
            width: 100%;
            max-height: 400px;
            object-fit: cover;
            border-radius: 8px;
            border: 2px solid var(--border);
        }

        .camera-preview canvas {
            display: none;
        }

        .capture-btn {
            margin-top: 12px;
            width: 100%;
            padding: 12px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
        }

        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
        }

        .processing-overlay.active {
            display: flex;
        }

        .processing-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .processing-text {
            font-size: 18px;
            font-weight: 500;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 16px;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 60px;
        }

        .coords-display {
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .modal-footer {
            padding: 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        /* Leaflet Custom Styles */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }

        /* Leaflet Routing Machine Customization */
        .leaflet-routing-container {
            display: none !important; /* Ocultar banner de navegação */
        }

        .leaflet-routing-container h2,
        .leaflet-routing-container h3 {
            color: var(--text-primary);
        }

        .leaflet-routing-alt {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
        }

        .leaflet-routing-alt:hover {
            background: var(--bg-primary);
        }

        .leaflet-routing-alt-minimized {
            background: var(--primary);
            color: white;
            border-radius: 8px;
        }

        .leaflet-routing-icon {
            color: var(--text-primary);
        }

        .leaflet-routing-geocoders {
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 6px;
        }

        .leaflet-routing-geocoder input {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px;
        }

        .popup-navigate-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            margin-bottom: 8px;
        }

        .popup-navigate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        /* Navigation Panel - Real-time GPS */
        .navigation-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--bg-primary);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 24px var(--shadow);
            z-index: 1500;
            min-width: 300px;
            display: none;
            animation: slideInRight 0.3s;
        }

        .navigation-panel.active {
            display: block;
        }

        .navigation-panel.collapsed .nav-stats {
            display: none;
        }

        .navigation-panel.collapsed .nav-status {
            display: none;
        }

        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .navigation-panel.collapsed .nav-header {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .nav-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 16px;
        }

        .nav-buttons {
            display: flex;
            gap: 6px;
        }

        .nav-toggle-btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 10px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .nav-toggle-btn:hover {
            background: var(--primary-hover);
        }

        .nav-close-btn {
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 10px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .nav-close-btn:hover {
            background: var(--danger-hover);
        }

        .nav-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .nav-stat {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }

        .nav-stat-label {
            color: var(--text-secondary);
        }

        .nav-stat-value {
            font-weight: 600;
            color: var(--primary);
        }

        .nav-status {
            text-align: center;
            padding: 8px;
            background: var(--success);
            color: white;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            margin-top: 8px;
        }

        .nav-status.calculating {
            background: #f59e0b;
        }

        .popup-content {
            min-width: 200px;
        }

        .popup-content h3 {
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .popup-content p {
            margin-bottom: 4px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .popup-buttons {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .popup-route-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .popup-route-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .popup-actions {
            display: flex;
            gap: 8px;
        }

        .popup-edit-btn,
        .popup-delete-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .popup-edit-btn {
            background: var(--primary);
            color: white;
        }

        .popup-edit-btn:hover {
            background: var(--primary-hover);
        }

        .popup-delete-btn {
            background: var(--danger);
            color: white;
        }

        .popup-delete-btn:hover {
            background: var(--danger-hover);
        }

        /* Loading Indicator */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 3000;
        }

        .spinner {
            border: 4px solid var(--border);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            max-width: 400px;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.hiding {
            animation: slideOutRight 0.3s ease forwards;
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            margin-bottom: 2px;
            color: var(--text-primary);
        }

        .toast-message {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        .toast.warning {
            border-left: 4px solid #f59e0b;
        }

        .toast.info {
            border-left: 4px solid var(--primary);
        }

        /* Responsive */
        /* ========== MOBILE OPTIMIZATION ========== */
        @media (max-width: 768px) {
            /* Sidebar Mobile */
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                width: 85vw;
                max-width: 350px;
                transform: translateX(-100%);
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
                z-index: 2000;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .menu-toggle {
                display: flex;
                position: fixed;
                top: 15px;
                left: 15px;
                z-index: 1500;
                background: var(--bg-primary);
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                min-width: 48px;
                min-height: 48px;
            }

            /* FAB Mobile - Botão de Adicionar Cliente */
            .fab {
                /* Posição mais alta para garantir visibilidade */
                bottom: 80px !important;
                width: 64px;
                height: 64px;
                font-size: 32px;
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
                z-index: 1400;
                /* Garante visibilidade total */
                margin-bottom: 0;
                pointer-events: auto;
                position: fixed;
                left: 50%;
                transform: translateX(-50%);
            }

            /* Garantir que FAB não seja cortado no active */
            .fab:active {
                transform: translateX(-50%) scale(0.92) !important;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }

            /* Impede hover em mobile para melhor performance */
            .fab:hover {
                transform: translateX(-50%) !important;
            }

            /* Toast Mobile */
            .toast {
                left: 15px;
                right: 15px;
                min-width: auto;
                max-width: calc(100vw - 30px);
                font-size: 14px;
                padding: 12px 16px;
            }

            /* Camera Preview - Mobile */
            .camera-preview {
                max-height: 250px;
            }

            .camera-preview video,
            .camera-preview canvas {
                max-height: 250px;
            }

            /* Modal Mobile */
            .modal {
                max-height: 90vh;
                overflow-y: auto;
                margin: 15px;
                max-width: calc(100vw - 30px);
                border-radius: 12px;
            }

            .modal-body {
                max-height: 65vh;
                overflow-y: auto;
                padding: 16px;
            }

            .modal-header {
                padding: 16px;
            }

            .modal-header h2 {
                font-size: 20px;
            }

            .modal-footer {
                padding: 12px 16px;
                gap: 8px;
            }

            /* Forms Mobile */
            .form-group {
                margin-bottom: 16px;
            }

            .form-group label {
                font-size: 14px;
                margin-bottom: 6px;
            }

            .form-group input,
            .form-group select,
            .form-group textarea {
                font-size: 16px !important; /* Previne zoom no iOS */
                padding: 12px;
                min-height: 48px; /* Touch target mínimo */
            }

            /* Buttons Mobile */
            .btn {
                min-height: 48px;
                padding: 12px 20px;
                font-size: 16px;
            }

            .btn-primary,
            .btn-secondary,
            .btn-danger {
                font-size: 15px;
                padding: 12px 18px;
            }

            /* Upload Section Mobile */
            .upload-section {
                padding: 12px;
            }

            .upload-btn {
                min-height: 48px;
                font-size: 15px;
                padding: 12px;
            }

            /* Search Mobile */
            .search-container {
                padding: 12px;
            }

            .search-input {
                font-size: 16px !important;
                min-height: 48px;
                padding: 12px 40px 12px 38px;
            }

            /* Client List Mobile */
            .clients-list {
                padding: 8px;
            }

            .client-item {
                padding: 14px 12px;
                margin-bottom: 10px;
                border-radius: 10px;
                min-height: 60px;
                tap-highlight-color: transparent;
                -webkit-tap-highlight-color: transparent;
            }

            .client-item:active {
                transform: scale(0.98);
            }

            .client-name {
                font-size: 15px;
                margin-bottom: 6px;
            }

            .client-address {
                font-size: 13px;
                line-height: 1.4;
            }

            /* Admin Panel Mobile */
            .admin-panel {
                width: 100vw;
                max-width: 100vw;
                left: 0;
                right: 0;
                border-radius: 0;
                z-index: 10000;
            }

            .admin-header {
                padding: 14px 16px;
                flex-wrap: wrap;
                gap: 10px;
            }

            .admin-header h1 {
                font-size: 20px;
                width: 100%;
                margin-bottom: 4px;
            }

            .admin-header-actions {
                width: 100%;
                flex-wrap: wrap;
                gap: 8px;
            }

            .admin-header-actions .btn,
            .admin-header-actions .logout-btn {
                flex: 1;
                min-width: calc(50% - 4px);
                justify-content: center;
            }

            .admin-content {
                padding: 12px;
            }

            .user-card {
                flex-direction: column;
                align-items: flex-start;
                padding: 14px 12px;
                margin-bottom: 12px;
                gap: 12px;
            }

            .user-info {
                width: 100%;
            }

            .user-info h3 {
                font-size: 16px;
                margin-bottom: 6px;
            }

            .user-info p {
                font-size: 13px;
                line-height: 1.4;
            }

            .user-actions {
                width: 100%;
                flex-wrap: wrap;
                gap: 8px;
            }

            .user-actions .btn {
                flex: 1;
                min-width: calc(50% - 4px);
                justify-content: center;
                font-size: 13px;
                padding: 10px 12px;
            }

            .admin-section {
                padding: 14px 12px;
                margin-bottom: 12px;
            }

            .admin-section h2 {
                font-size: 18px;
                margin-bottom: 12px;
            }

            /* Botão de voltar do admin */
            #closeAdminBtn {
                min-height: 40px;
                padding: 10px 16px;
                font-size: 14px;
                white-space: nowrap;
            }

            /* Botão adicionar usuário */
            #addUserBtn {
                min-height: 44px;
                padding: 10px 16px;
                font-size: 14px;
            }

            /* Login Mobile */
            .login-box {
                padding: 30px 24px;
                width: 92%;
                max-width: 400px;
            }

            .login-header h1 {
                font-size: 24px;
            }

            .login-header p {
                font-size: 14px;
            }

            /* Map Controls Mobile */
            .leaflet-top,
            .leaflet-bottom {
                z-index: 400;
            }

            .leaflet-control-zoom {
                margin-top: 70px !important;
            }

            .leaflet-control-zoom a {
                width: 40px !important;
                height: 40px !important;
                line-height: 40px !important;
                font-size: 22px !important;
            }

            /* QR Code Button Mobile */
            #qrBtn {
                min-width: 48px;
                min-height: 48px;
                padding: 12px;
                border-radius: 10px;
            }

            /* Navigation Controls Mobile */
            .nav-close-btn {
                min-height: 44px;
                padding: 10px 16px;
                font-size: 15px;
            }

            /* Reduce animations on mobile for performance */
            * {
                -webkit-transform: translateZ(0);
                transform: translateZ(0);
            }

            /* Disable hover effects on touch devices */
            .client-item:hover,
            .btn:hover,
            .upload-btn:hover {
                transform: none;
            }

            /* Improve scrolling performance */
            .clients-list,
            .modal-body,
            .admin-content {
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }
        }

        /* Small Mobile Devices (< 375px) */
        @media (max-width: 375px) {
            .sidebar {
                width: 90vw;
            }

            .modal {
                margin: 10px;
                max-width: calc(100vw - 20px);
            }

            .login-box {
                padding: 24px 18px;
            }

            .btn {
                font-size: 14px;
                padding: 11px 16px;
            }

            /* Admin Panel - Small Mobile */
            .admin-header h1 {
                font-size: 18px;
            }

            .user-card {
                padding: 12px 10px;
            }

            .user-info h3 {
                font-size: 15px;
            }

            .user-actions .btn {
                font-size: 12px;
                padding: 8px 10px;
            }

            #closeAdminBtn,
            #addUserBtn {
                font-size: 13px;
                padding: 8px 14px;
            }

            /* FAB em telas muito pequenas */
            .fab {
                width: 60px;
                height: 60px;
                font-size: 28px;
                bottom: 70px !important;
            }
        }

        /* Landscape Mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .modal {
                max-height: 85vh;
            }

            .modal-body {
                max-height: 55vh;
            }

            .sidebar {
                width: 60vw;
                max-width: 400px;
            }

            .fab {
                bottom: 80px !important;
                width: 60px;
                height: 60px;
                font-size: 28px;
            }
        }

        /* Sidebar Overlay for Mobile */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar-overlay.active {
            display: block;
            opacity: 1;
        }

        /* Performance Optimizations */
        .sidebar,
        .modal-overlay,
        .admin-panel,
        .menu-toggle,
        .fab {
            will-change: transform;
        }

        /* Prevent text selection on touch */
        .btn,
        .client-item,
        .menu-toggle,
        .fab {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Better tap highlighting */
        a, button, .client-item {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0.05);
            tap-highlight-color: rgba(0, 0, 0, 0.05);
        }

        /* Login Screen */
        .login-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .login-container.hidden {
            display: none;
        }

        .login-box {
            background: var(--bg-primary);
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .login-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .login-header h1 {
            color: var(--text-primary);
            margin: 0 0 8px 0;
            font-size: 28px;
        }

        .login-header p {
            color: var(--text-secondary);
            margin: 0;
            font-size: 14px;
        }

        .login-form .form-group {
            margin-bottom: 20px;
        }

        .login-form label {
            display: block;
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .login-form input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.2s;
        }

        .login-form input:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-primary);
        }

        .login-form input.error {
            border-color: var(--danger);
            background: rgba(239, 68, 68, 0.05);
        }

        .login-form input.success {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.05);
        }

        .error-message {
            display: none;
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
            color: var(--danger);
            padding: 12px 16px;
            border-radius: 6px;
            margin: 16px 0;
            font-size: 14px;
            animation: slideDown 0.3s ease;
        }

        .error-message.show {
            display: block;
        }

        .error-message strong {
            display: block;
            margin-bottom: 4px;
        }

        .field-error {
            color: var(--danger);
            font-size: 12px;
            margin-top: 4px;
            display: none;
        }

        .field-error.show {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .login-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .login-btn:hover {
            transform: translateY(-2px);
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .register-btn {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .register-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        /* Admin Panel */
        .admin-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-secondary);
            z-index: 9999;
            overflow-y: auto;
            display: none;
        }

        .admin-panel.active {
            display: block;
        }

        .admin-header {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .admin-header h1 {
            margin: 0;
            color: var(--text-primary);
            font-size: 24px;
        }

        .admin-header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .admin-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .user-card {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-info h3 {
            margin: 0 0 8px 0;
            color: var(--text-primary);
        }

        .user-info p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .user-actions {
            display: flex;
            gap: 8px;
        }

        .user-badge {
            display: inline-block;
            padding: 4px 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .logout-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .logout-btn:hover {
            background: var(--danger-hover);
        }

        .admin-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
        }

        .user-header-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--bg-primary);
            padding: 12px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 1500;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            transition: opacity 0.3s ease;
        }

        .user-header-info span {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 14px;
        }

        /* Mobile User Header */
        @media (max-width: 768px) {
            .login-box {
                padding: 30px 20px;
            }

            .user-header-info {
                top: 15px;
                right: 15px;
                left: auto;
                bottom: auto;
                padding: 10px 12px;
                gap: 8px;
                max-width: calc(100vw - 80px);
                border-radius: 10px;
            }

            .user-header-info span {
                font-size: 13px;
                max-width: 100px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .admin-btn {
                font-size: 13px !important;
                padding: 8px 12px !important;
                margin-right: 0 !important;
                min-width: 70px;
                white-space: nowrap;
            }

            .logout-btn {
                font-size: 13px !important;
                padding: 8px 12px !important;
                min-width: 55px;
                white-space: nowrap;
            }
        }

        /* Small Mobile - Stack vertically if needed */
        @media (max-width: 375px) {
            .user-header-info {
                flex-direction: column;
                align-items: flex-end;
                gap: 6px;
                padding: 8px 10px;
                max-width: calc(100vw - 80px);
            }

            .user-header-info span {
                font-size: 12px;
                max-width: 120px;
            }

            .admin-btn,
            .logout-btn {
                font-size: 12px !important;
                padding: 6px 10px !important;
                width: 100%;
                min-width: auto;
            }
        }

        /* Melhorias de qualidade para mapa em mobile */
        .mobile-tiles-hq img {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }

        /* Melhorar renderização do Leaflet em telas de alta DPI */
        .leaflet-container {
            image-rendering: -webkit-optimize-contrast;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Tiles de alta qualidade */
        .leaflet-tile-container img {
            image-rendering: -webkit-optimize-contrast;
        }

        /* Melhorar renderização de texto nos popups mobile */
        .leaflet-popup-content {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        /* Otimizar renderização dos marcadores */
        .numbered-marker {
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        /* Controles do Mapa (estilo Amazon Flex) */
        .map-controls {
            position: absolute;
            top: 80px;
            right: 16px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .map-control-btn {
            background: white;
            border: none;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            transition: all 0.2s;
            min-width: 50px;
        }

        .map-control-btn:hover {
            background: #f3f4f6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .map-control-btn:active {
            transform: scale(0.95);
        }

        .map-control-btn svg {
            width: 24px;
            height: 24px;
            color: #2563eb;
        }

        #mapTypeLabel {
            white-space: nowrap;
        }

        /* Contador de Entregas */
        .delivery-counter {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 140px;
        }

        .counter-label {
            font-size: 12px;
            color: #6b7280;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .counter-value {
            font-size: 24px;
            font-weight: bold;
            color: #111827;
            margin-bottom: 8px;
        }

        .counter-progress {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .map-controls {
                top: 70px;
                right: 12px;
                gap: 10px;
            }

            .map-control-btn {
                padding: 10px;
                border-radius: 6px;
            }

            .map-control-btn svg {
                width: 20px;
                height: 20px;
            }

            #mapTypeLabel {
                font-size: 12px;
            }

            .delivery-counter {
                padding: 12px;
                min-width: 120px;
            }

            .counter-label {
                font-size: 10px;
            }

            .counter-value {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-container" id="loginContainer">
        <div class="login-box">
            <div class="login-header">
                <h1>🗺️ Sistema GPS</h1>
                <p>Faça login para acessar o sistema</p>
            </div>
            <form class="login-form" id="loginForm">
                <!-- Mensagem de erro geral -->
                <div class="error-message" id="loginError"></div>

                <div class="form-group">
                    <label for="loginUsername">Usuário</label>
                    <input type="text" id="loginUsername" required autocomplete="username">
                    <div class="field-error" id="loginUsernameError"></div>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Senha</label>
                    <input type="password" id="loginPassword" required autocomplete="current-password">
                    <div class="field-error" id="loginPasswordError"></div>
                </div>
                <button type="submit" class="login-btn" id="loginBtn">Entrar</button>
            </form>
            <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border);">
                <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 10px;">Não tem uma conta?</p>
                <button type="button" class="register-btn" id="showRegisterBtn">📝 Cadastrar como Entregador</button>
            </div>
        </div>
    </div>

    <!-- Register Screen -->
    <div class="login-container hidden" id="registerContainer">
        <div class="login-box">
            <div class="login-header">
                <h1>📝 Cadastro de Entregador</h1>
                <p>Preencha os dados para criar sua conta</p>
            </div>
            <form class="login-form" id="registerForm">
                <!-- Mensagem de erro geral -->
                <div class="error-message" id="registerError"></div>

                <div class="form-group">
                    <label for="registerName">Nome Completo *</label>
                    <input type="text" id="registerName" required placeholder="Digite seu nome completo">
                    <div class="field-error" id="registerNameError"></div>
                </div>
                <div class="form-group">
                    <label for="registerUsername">Usuário *</label>
                    <input type="text" id="registerUsername" required placeholder="Escolha um nome de usuário" autocomplete="username">
                    <div class="field-error" id="registerUsernameError"></div>
                </div>
                <div class="form-group">
                    <label for="registerPassword">Senha *</label>
                    <input type="password" id="registerPassword" required placeholder="Escolha uma senha" autocomplete="new-password">
                    <div class="field-error" id="registerPasswordError"></div>
                </div>
                <div class="form-group">
                    <label for="registerPasswordConfirm">Confirmar Senha *</label>
                    <input type="password" id="registerPasswordConfirm" required placeholder="Digite a senha novamente" autocomplete="new-password">
                    <div class="field-error" id="registerPasswordConfirmError"></div>
                </div>
                <button type="submit" class="login-btn" id="registerBtn">Criar Conta</button>
            </form>
            <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border);">
                <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 10px;">Já tem uma conta?</p>
                <button type="button" class="register-btn" id="showLoginBtn">🔑 Fazer Login</button>
            </div>
        </div>
    </div>

    <!-- Admin Panel -->
    <div class="admin-panel" id="adminPanel">
        <div class="admin-header">
            <h1>👥 Gerenciar Usuários</h1>
            <div class="admin-header-actions">
                <button class="btn btn-primary" id="addUserBtn">➕ Novo Usuário</button>
                <button class="logout-btn" id="closeAdminBtn">Voltar</button>
            </div>
        </div>
        <div class="admin-content">
            <div id="usersList"></div>
        </div>
    </div>

    <!-- User Info Header -->
    <div class="user-header-info" id="userHeaderInfo" style="display: none;">
        <span id="currentUsername">Usuário</span>
        <button class="admin-btn" id="openAdminBtn" style="display: none;">👥 Admin</button>
        <button class="admin-btn" id="openSettingsBtn" style="display: none;">⚙️ Config</button>
        <button class="logout-btn" id="logoutBtn">Sair</button>
    </div>

    <!-- Settings Panel -->
    <div class="admin-panel" id="settingsPanel">
        <div class="admin-header">
            <h1>⚙️ Configurações Globais</h1>
            <button class="close-admin-btn" id="closeSettingsBtn">×</button>
        </div>
        <div class="admin-content">
            <div style="background: #fff; border-radius: 8px; padding: 20px; margin-bottom: 16px;">
                <h3 style="margin: 0 0 8px 0; font-size: 16px; color: #374151;">🗺️ Google Maps Platform API Key</h3>
                <p style="margin: 0 0 16px 0; font-size: 13px; color: #6b7280; line-height: 1.5;">
                    ⚠️ <strong>OBRIGATÓRIO para roteirização!</strong> Configure uma vez e todos os usuários poderão usar. O sistema usa APENAS Google Maps para garantir rotas precisas com dados de trânsito em tempo real (gratuita até 28.500 rotas/mês).
                    <br><a href="https://console.cloud.google.com/" target="_blank" style="color: #2563eb; font-weight: 600;">Obter API Key gratuita →</a>
                </p>
                <div style="margin-bottom: 12px;">
                    <label style="display: block; margin-bottom: 6px; font-size: 13px; font-weight: 600; color: #374151;">
                        API Key (Maps Platform):
                    </label>
                    <input
                        type="text"
                        id="googleMapsApiKey"
                        placeholder="Cole sua Google Maps Platform API Key aqui"
                        style="width: 100%; padding: 10px 12px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 14px; font-family: monospace;"
                    >
                </div>
                <div style="display: flex; gap: 8px; margin-top: 16px;">
                    <button id="testApiKeyBtn" style="background: #3b82f6; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-weight: 600; cursor: pointer;">
                        🧪 Testar
                    </button>
                    <button id="saveApiKeyBtn" style="flex: 1; background: #10b981; color: white; border: none; padding: 10px; border-radius: 6px; font-weight: 600; cursor: pointer;">
                        💾 Salvar
                    </button>
                    <button id="clearApiKeyBtn" style="background: #ef4444; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-weight: 600; cursor: pointer;">
                        🗑️ Limpar
                    </button>
                </div>
                <div id="apiKeyStatus" style="margin-top: 12px; padding: 10px; border-radius: 6px; font-size: 13px; display: none;"></div>
            </div>

            <div style="background: #fff; border-radius: 8px; padding: 20px;">
                <h3 style="margin: 0 0 8px 0; font-size: 16px; color: #374151;">ℹ️ Informações</h3>
                <div style="font-size: 13px; color: #6b7280; line-height: 1.6;">
                    <p style="margin: 0 0 8px 0;"><strong>Sistema:</strong> Usa exclusivamente Google Maps Platform API</p>
                    <p style="margin: 0 0 8px 0;"><strong>Vantagens:</strong> Rotas mais precisas, dados de trânsito em tempo real, melhor navegação</p>
                    <p style="margin: 0 0 8px 0;"><strong>Custo:</strong> GRATUITO até 28.500 rotas/mês (200 USD/mês em créditos)</p>
                    <p style="margin: 0;"><strong>Requisitos:</strong> Directions API ativada no Google Cloud Console</p>
                </div>
            </div>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>Obtendo sua localização...</p>
    </div>

    <div class="app-container" id="appContainer" style="display: none;">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1>📍 Meus Clientes</h1>
                <p id="clientCount">0 clientes cadastrados</p>
            </div>

            <!-- Upload Planilha -->
            <div class="upload-section">
                <button class="upload-btn" id="uploadBtn" title="Upload planilha Excel com códigos BR e endereços">
                    📊 Carregar Planilha Excel
                </button>
                <input type="file" id="uploadInput" class="upload-input" accept=".xlsx,.xls,.csv">
                <div class="upload-status" id="uploadStatus"></div>

                <button class="upload-btn" id="optimizeRouteBtn" style="margin-top: 8px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); display: none;" title="Roteirizar endereços da planilha com IA">
                    🤖 Roteirizar com IA
                </button>
                <div class="upload-status" id="routeStatus"></div>
            </div>

            <!-- Search Box -->
            <div class="search-container">
                <div class="search-box">
                    <span class="search-icon">🔍</span>
                    <input
                        type="text"
                        class="search-input"
                        id="searchInput"
                        placeholder="Buscar por nome ou endereço..."
                        autocomplete="off"
                    >
                    <button class="clear-search" id="clearSearch" title="Limpar busca">×</button>
                </div>
                <div class="search-results-info" id="searchResultsInfo"></div>
            </div>

            <div class="clients-list" id="clientsList">
                <div class="empty-state">
                    <svg fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd"/>
                    </svg>
                    <p>Nenhum cliente cadastrado ainda</p>
                    <p style="font-size: 12px; margin-top: 8px;">Use o botão + para adicionar</p>
                </div>
            </div>
        </div>

        <!-- Sidebar Overlay for Mobile -->
        <div class="sidebar-overlay" id="sidebarOverlay"></div>

        <!-- Map -->
        <div id="map"></div>

        <!-- Controles do Mapa (estilo Amazon Flex) -->
        <div class="map-controls">
            <!-- Botão Alternar Mapa/Satélite -->
            <button class="map-control-btn" id="toggleMapTypeBtn" title="Alternar Mapa/Satélite" onclick="toggleMapType()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5zm0 18.5C7.61 19.4 5 15.27 5 11V8.3l7-3.12 7 3.12V11c0 4.27-2.61 8.4-7 9.5z"/>
                </svg>
                <span id="mapTypeLabel">Satélite</span>
            </button>

            <!-- Botão Recentralizar GPS -->
            <button class="map-control-btn" id="recenterBtn" title="Recentralizar no GPS" onclick="recenterMap()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>
                </svg>
            </button>

            <!-- Contador de Entregas -->
            <div class="delivery-counter" id="deliveryCounter" style="display: none;">
                <div class="counter-label">Entregas</div>
                <div class="counter-value">
                    <span id="deliveredCount">0</span> / <span id="totalCount">0</span>
                </div>
                <div class="counter-progress">
                    <div class="progress-bar" id="deliveryProgress"></div>
                </div>
            </div>
        </div>

        <!-- Mobile Menu Toggle -->
        <button class="menu-toggle" id="menuToggle">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
        </button>

        <!-- Floating Action Button -->
        <button class="fab" id="addClientBtn" title="Adicionar cliente aqui">+</button>

        <!-- Navigation Panel - Real-time GPS -->
        <div class="navigation-panel collapsed" id="navigationPanel">
            <div class="nav-header">
                <div class="nav-title">🧭 Navegação Ativa</div>
                <div class="nav-buttons">
                    <button class="nav-toggle-btn" id="navToggleBtn" onclick="toggleNavigationPanel()">Ver</button>
                    <button class="nav-close-btn" onclick="stopRealtimeNavigation()">Parar</button>
                </div>
            </div>
            <div class="nav-stats">
                <div class="nav-stat">
                    <span class="nav-stat-label">Destino:</span>
                    <span class="nav-stat-value" id="navDestination">-</span>
                </div>
                <div class="nav-stat">
                    <span class="nav-stat-label">Distância:</span>
                    <span class="nav-stat-value" id="navDistance">-</span>
                </div>
                <div class="nav-stat">
                    <span class="nav-stat-label">Tempo:</span>
                    <span class="nav-stat-value" id="navTime">-</span>
                </div>
            </div>
            <div class="nav-status" id="navStatus">🚗 Navegando...</div>
        </div>
    </div>

    <!-- Add Client Modal -->
    <div class="modal-overlay" id="addClientModal">
        <div class="modal">
            <div class="modal-header">
                <h2>Adicionar Novo Cliente</h2>
            </div>
            <div class="modal-body">
                <!-- QR Code Scanner Section -->
                <div class="camera-section">
                    <button type="button" class="scan-btn" id="scanBtn">
                        📷 Escanear QR Code
                    </button>
                    <div class="camera-preview" id="cameraPreview">
                        <video id="cameraVideo" autoplay playsinline></video>
                        <canvas id="cameraCanvas"></canvas>
                    </div>
                </div>

                <form id="clientForm">
                    <div class="form-group">
                        <label for="clientName">Nome do Cliente *</label>
                        <input type="text" id="clientName" required placeholder="Digite o nome do cliente">
                    </div>
                    <div class="form-group">
                        <label for="clientAddress">Endereço *</label>
                        <textarea id="clientAddress" required placeholder="Digite o endereço completo"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="clientPhone">Telefone</label>
                        <input type="tel" id="clientPhone" placeholder="(99) 99942-1942" maxlength="15">
                    </div>
                    <div class="form-group">
                        <label for="clientBR">BR</label>
                        <input type="text" id="clientBR" placeholder="Informação do QR Code">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="cancelBtn">Cancelar</button>
                <button type="submit" form="clientForm" class="btn btn-primary">Salvar Cliente</button>
            </div>
        </div>
    </div>

    <!-- Processing Overlay -->
    <div class="processing-overlay" id="processingOverlay">
        <div class="processing-spinner"></div>
        <div class="processing-text">Lendo QR Code...</div>
    </div>

    <!-- Edit Client Modal -->
    <div class="modal-overlay" id="editClientModal">
        <div class="modal">
            <div class="modal-header">
                <h2>Editar Cliente</h2>
            </div>
            <div class="modal-body">
                <form id="editClientForm">
                    <div class="form-group">
                        <label for="editClientName">Nome do Cliente *</label>
                        <input type="text" id="editClientName" required placeholder="Digite o nome do cliente">
                    </div>
                    <div class="form-group">
                        <label for="editClientAddress">Endereço *</label>
                        <textarea id="editClientAddress" required placeholder="Digite o endereço completo"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="editClientPhone">Telefone</label>
                        <input type="tel" id="editClientPhone" placeholder="(99) 99942-1942" maxlength="15">
                    </div>
                    <div class="form-group">
                        <label for="editClientBR">BR</label>
                        <input type="text" id="editClientBR" placeholder="Informação do QR Code">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="editCancelBtn">Cancelar</button>
                <button type="submit" form="editClientForm" class="btn btn-primary">Salvar Alterações</button>
            </div>
        </div>
    </div>

    <!-- Add User Modal -->
    <div class="modal-overlay" id="addUserModal">
        <div class="modal">
            <div class="modal-header">
                <h2>Adicionar Novo Usuário</h2>
            </div>
            <div class="modal-body">
                <form id="userForm">
                    <div class="form-group">
                        <label for="newUserName">Nome Completo *</label>
                        <input type="text" id="newUserName" required placeholder="Digite o nome completo">
                    </div>
                    <div class="form-group">
                        <label for="newUsername">Nome de Usuário *</label>
                        <input type="text" id="newUsername" required placeholder="Digite o nome de usuário">
                    </div>
                    <div class="form-group">
                        <label for="newUserPassword">Senha *</label>
                        <input type="password" id="newUserPassword" required placeholder="Digite a senha">
                    </div>
                    <div class="form-group">
                        <label for="newUserRole">Tipo de Usuário</label>
                        <select id="newUserRole" style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary);">
                            <option value="user">Usuário</option>
                            <option value="admin">Administrador</option>
                        </select>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="cancelUserBtn">Cancelar</button>
                <button type="submit" form="userForm" class="btn btn-primary">Criar Usuário</button>
            </div>
        </div>
    </div>

    <!-- Edit User Modal -->
    <div class="modal-overlay" id="editUserModal">
        <div class="modal">
            <div class="modal-header">
                <h2>Editar Usuário</h2>
            </div>
            <div class="modal-body">
                <form id="editUserForm">
                    <div class="form-group">
                        <label for="editUserName">Nome Completo *</label>
                        <input type="text" id="editUserName" required placeholder="Digite o nome completo">
                    </div>
                    <div class="form-group">
                        <label for="editUsername">Nome de Usuário *</label>
                        <input type="text" id="editUsername" required placeholder="Digite o nome de usuário">
                    </div>
                    <div class="form-group">
                        <label for="editUserPassword">Nova Senha (deixe em branco para não alterar)</label>
                        <input type="password" id="editUserPassword" placeholder="Digite a nova senha">
                    </div>
                    <div class="form-group">
                        <label for="editUserRole">Tipo de Usuário</label>
                        <select id="editUserRole" style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary);">
                            <option value="user">Usuário</option>
                            <option value="admin">Administrador</option>
                        </select>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="cancelEditUserBtn">Cancelar</button>
                <button type="submit" form="editUserForm" class="btn btn-primary">Salvar Alterações</button>
            </div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirmModal">
        <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
                <h2 id="confirmTitle">Confirmar ação</h2>
            </div>
            <div class="modal-body">
                <p id="confirmMessage" style="color: var(--text-primary); font-size: 15px; line-height: 1.6;"></p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="confirmCancelBtn">Cancelar</button>
                <button type="button" class="btn btn-danger" id="confirmOkBtn">Confirmar</button>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Leaflet Routing Machine JS -->
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- jsQR (QR Code Scanner) -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <!-- SheetJS (Excel Reader) -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <script>
        // Toast Notification System
        function showToast(message, type = 'info', title = '') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icons = {
                error: '❌',
                warning: '⚠️',
                info: 'ℹ️',
                success: '✓'
            };

            const titles = {
                error: title || 'Erro',
                warning: title || 'Aviso',
                info: title || 'Informação',
                success: title || 'Sucesso'
            };

            toast.innerHTML = `
                <div class="toast-icon">${icons[type]}</div>
                <div class="toast-content">
                    <div class="toast-title">${titles[type]}</div>
                    <div class="toast-message">${message}</div>
                </div>
            `;

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('hiding');
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 4000);
        }

        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Supabase Configuration
        // IMPORTANTE: Substitua estas variáveis pelas suas credenciais do Supabase
        const SUPABASE_URL = 'https://pnecrzwlyxjirdjfiman.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBuZWNyendseXhqaXJkamZpbWFuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQyOTQ2NzksImV4cCI6MjA3OTg3MDY3OX0.2REOdgPBvGBZUrLT_ggUU6HqbunamouGaihjibH1jhs';

        // Inicializar Supabase (será null se não configurado)
        let supabase = null;
        try {
            if (SUPABASE_URL.includes('seu-projeto') || SUPABASE_ANON_KEY.includes('sua-chave')) {
                console.warn('⚠️ Supabase não configurado. Usando armazenamento local.');
            } else {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('✅ Supabase conectado com sucesso!');
            }
        } catch (error) {
            console.error('Erro ao conectar com Supabase:', error);
        }

        // ========== FUNÇÃO DE CONFIRMAÇÃO CUSTOMIZADA ==========

        // Substituir confirm() nativo por modal customizado
        function customConfirm(message, title = 'Confirmar ação') {
            return new Promise((resolve) => {
                const confirmModal = document.getElementById('confirmModal');
                const confirmTitle = document.getElementById('confirmTitle');
                const confirmMessage = document.getElementById('confirmMessage');
                const confirmOkBtn = document.getElementById('confirmOkBtn');
                const confirmCancelBtn = document.getElementById('confirmCancelBtn');

                confirmTitle.textContent = title;
                confirmMessage.textContent = message;
                confirmModal.classList.add('active');

                const handleOk = () => {
                    confirmModal.classList.remove('active');
                    confirmOkBtn.removeEventListener('click', handleOk);
                    confirmCancelBtn.removeEventListener('click', handleCancel);
                    confirmModal.removeEventListener('click', handleOutsideClick);
                    resolve(true);
                };

                const handleCancel = () => {
                    confirmModal.classList.remove('active');
                    confirmOkBtn.removeEventListener('click', handleOk);
                    confirmCancelBtn.removeEventListener('click', handleCancel);
                    confirmModal.removeEventListener('click', handleOutsideClick);
                    resolve(false);
                };

                const handleOutsideClick = (e) => {
                    if (e.target === confirmModal) {
                        handleCancel();
                    }
                };

                confirmOkBtn.addEventListener('click', handleOk);
                confirmCancelBtn.addEventListener('click', handleCancel);
                confirmModal.addEventListener('click', handleOutsideClick);
            });
        }

        // Application State
        const state = {
            map: null,
            currentLocation: null,
            currentLocationMarker: null,
            clients: [],
            clientMarkers: [],
            nextId: 1,
            searchQuery: '',
            editingClientId: null,
            useSupabase: supabase !== null,
            brDatabase: {}, // Armazena mapeamento BR -> Endereço
            routingControl: null, // Controle de navegação
            navigationActive: false, // Navegação GPS em tempo real ativa
            navigationWatchId: null, // ID do watchPosition
            navigationDestination: null, // Destino da navegação
            currentRoute: null, // Rota atual
            viewingOptimizedRoute: false, // Flag para indicar que está visualizando rota otimizada
            currentUser: null, // Usuário logado
            editingUserId: null, // ID do usuário sendo editado
            syncPollingInterval: null, // Interval para sincronização automática (polling)
            deliveredStops: new Set(), // Set de índices das paradas entregues
            optimizedOrder: null, // Ordem otimizada atual das paradas
            mapLayers: null, // Layers do mapa (streets, satellite, hybrid)
            currentMapLayer: 'streets', // Layer atual do mapa
            googleMapsApiKey: null, // API Key do Google Maps (opcional)
            routeData: [], // Dados das paradas para roteamento
            routePolylines: [] // Polylines desenhadas no mapa
        };

        // ========== SISTEMA DE AUTENTICAÇÃO ==========

        // Verificar sessão ao carregar
        async function checkSession() {
            // eslint-disable-next-line no-restricted-globals
            const sessionUser = localStorage.getItem('gps_user');
            if (sessionUser) {
                try {
                    state.currentUser = JSON.parse(sessionUser);
                    await showApp();
                    return true;
                } catch (error) {
                    console.error('Erro ao recuperar sessão:', error);
                    // eslint-disable-next-line no-restricted-globals
                    localStorage.removeItem('gps_user');
                }
            }
            return false;
        }

        // ========== CONFIGURAÇÕES GLOBAIS ==========

        // Carregar configurações globais (API Key, etc)
        async function loadGlobalSettings() {
            if (!state.useSupabase) return;

            try {
                // Buscar configuração global (usaremos um registro fixo com id=1)
                const { data, error } = await supabase
                    .from('settings')
                    .select('*')
                    .eq('id', 1)
                    .single();

                if (!error && data && data.google_maps_api_key) {
                    state.googleMapsApiKey = data.google_maps_api_key;
                    console.log('✅ API Key do Google Maps carregada');
                }
            } catch (error) {
                console.warn('Configurações globais não encontradas (normal na primeira vez)');
            }
        }

        // Salvar configuração global da API Key (apenas admin)
        async function saveGlobalSettings(apiKey) {
            if (!state.useSupabase) {
                showToast('Erro: Supabase não configurado', 'error');
                return false;
            }

            // Verificar se é admin
            if (!state.currentUser || state.currentUser.role !== 'admin') {
                showToast('Erro: Apenas administradores podem alterar configurações', 'error');
                return false;
            }

            try {
                // Tentar atualizar primeiro
                const { data: existingData } = await supabase
                    .from('settings')
                    .select('id')
                    .eq('id', 1)
                    .single();

                if (existingData) {
                    // Atualizar registro existente
                    const { error } = await supabase
                        .from('settings')
                        .update({ google_maps_api_key: apiKey })
                        .eq('id', 1);

                    if (error) throw error;
                } else {
                    // Criar novo registro
                    const { error } = await supabase
                        .from('settings')
                        .insert([{ id: 1, google_maps_api_key: apiKey }]);

                    if (error) throw error;
                }

                state.googleMapsApiKey = apiKey;
                return true;

            } catch (error) {
                console.error('Erro ao salvar configurações:', error);
                showToast('Erro ao salvar configurações', 'error');
                return false;
            }
        }

        // Login
        async function login(username, password) {
            if (!state.useSupabase) {
                showToast('Erro: Supabase não configurado', 'error');
                return false;
            }

            try {
                // CORREÇÃO: Usar ilike para aceitar maiúsculas/minúsculas no username
                const { data, error } = await supabase
                    .from('users')
                    .select('*')
                    .ilike('username', username)
                    .single();

                if (error || !data) {
                    showToast('Usuário ou senha incorretos', 'error');
                    return false;
                }

                // Verificar senha (em produção, use hash como bcrypt)
                if (data.password !== password) {
                    showToast('Usuário ou senha incorretos', 'error');
                    return false;
                }

                // Salvar sessão
                state.currentUser = {
                    id: data.id,
                    username: data.username,
                    role: data.role || 'user'
                };

                // eslint-disable-next-line no-restricted-globals
                localStorage.setItem('gps_user', JSON.stringify(state.currentUser));

                // Carregar configuração global da API Key
                await loadGlobalSettings();

                await showApp();
                return true;

            } catch (error) {
                console.error('Erro no login:', error);
                showToast('Erro ao fazer login', 'error');
                return false;
            }
        }

        // Logout
        function logout() {
            console.log('👋 Fazendo logout...');

            state.currentUser = null;
            // eslint-disable-next-line no-restricted-globals
            localStorage.removeItem('gps_user');

            // CRÍTICO: Limpar TODOS os dados
            state.clients = [];
            state.routeData = [];
            state.brDatabase = {};
            state.uploadSessionId = null; // Invalidar sessão de upload
            state.deliveredStops.clear(); // Limpar status de entrega

            // Cancelar sincronização automática
            if (state.syncPollingInterval) {
                clearInterval(state.syncPollingInterval);
                state.syncPollingInterval = null;
                console.log('🔕 Sincronização automática desativada');
            }

            // Limpar marcadores do mapa
            if (state.clientMarkers && state.clientMarkers.length > 0) {
                state.clientMarkers.forEach(m => {
                    if (state.map && m.marker) {
                        state.map.removeLayer(m.marker);
                    }
                });
                state.clientMarkers = [];
            }

            // Limpar polylines de rota
            if (state.routePolyline && state.map) {
                state.map.removeLayer(state.routePolyline);
                state.routePolyline = null;
            }

            // Limpar lista visual de clientes
            const clientList = document.getElementById('clientsList');
            if (clientList) {
                clientList.innerHTML = '';
            }

            // Atualizar contador
            const countElement = document.getElementById('clientCount');
            if (countElement) {
                countElement.textContent = '0 clientes cadastrados';
            }

            // Limpar mensagens de status de upload
            const uploadStatus = document.getElementById('uploadStatus');
            if (uploadStatus) {
                uploadStatus.textContent = '';
                uploadStatus.className = 'upload-status';
            }

            // Esconder app e mostrar login
            document.getElementById('appContainer').style.display = 'none';
            document.getElementById('userHeaderInfo').style.display = 'none';
            document.getElementById('loginContainer').classList.remove('hidden');
            document.getElementById('adminPanel').classList.remove('active');

            // Resetar formulário e botão de login
            const loginForm = document.getElementById('loginForm');
            const loginBtn = document.getElementById('loginBtn');
            if (loginForm) loginForm.reset();
            if (loginBtn) {
                loginBtn.disabled = false;
                loginBtn.textContent = 'Entrar';
            }

            console.log('✅ Logout concluído. Todos os dados limpos.');
        }

        // Mostrar aplicação após login
        async function showApp() {
            console.log(`🔐 Iniciando sessão para usuário: ${state.currentUser.username} (ID: ${state.currentUser.id})`);

            // CRÍTICO: Limpar TODOS os dados do usuário anterior antes de carregar novos dados
            console.log('🧹 Limpando dados da sessão anterior...');

            // Limpar clientes do estado
            state.clients = [];
            state.routeData = [];
            state.uploadSessionId = null;

            // Limpar todos os marcadores do mapa
            if (state.clientMarkers && state.clientMarkers.length > 0) {
                state.clientMarkers.forEach(m => {
                    if (state.map && m.marker) {
                        state.map.removeLayer(m.marker);
                    }
                });
                state.clientMarkers = [];
            }

            // Limpar polylines de rota
            if (state.routePolyline && state.map) {
                state.map.removeLayer(state.routePolyline);
                state.routePolyline = null;
            }

            // Limpar lista visual de clientes
            const clientList = document.getElementById('clientsList');
            if (clientList) {
                clientList.innerHTML = '';
            }

            // Atualizar contador
            const countElement = document.getElementById('clientCount');
            if (countElement) {
                countElement.textContent = '0 clientes cadastrados';
            }

            // Limpar mensagens de status de uploads anteriores
            const uploadStatus = document.getElementById('uploadStatus');
            if (uploadStatus) {
                uploadStatus.textContent = '';
                uploadStatus.className = 'upload-status';
            }

            console.log('✅ Dados limpos. Carregando dados do usuário atual...');

            document.getElementById('loginContainer').classList.add('hidden');
            document.getElementById('registerContainer').classList.add('hidden');
            document.getElementById('appContainer').style.display = 'flex'; // CRÍTICO: usar flex para layout correto
            document.getElementById('userHeaderInfo').style.display = 'flex';
            document.getElementById('currentUsername').textContent = state.currentUser.username;

            // Mostrar botões admin apenas para administradores
            if (state.currentUser.role === 'admin') {
                document.getElementById('openAdminBtn').style.display = 'block';
                document.getElementById('openSettingsBtn').style.display = 'block';
            } else {
                document.getElementById('openAdminBtn').style.display = 'none';
                document.getElementById('openSettingsBtn').style.display = 'none';
            }

            // Inicializar mapa se ainda não foi inicializado
            if (!state.map) {
                console.log('🗺️ Inicializando mapa após login...');
                getCurrentLocation();
            } else {
                // Mapa já existe, corrigir tamanho após mostrar container
                hideLoading();

                // CRÍTICO: Aguardar renderização do DOM antes de invalidar tamanho
                setTimeout(() => {
                    if (state.map) {
                        state.map.invalidateSize();
                        console.log('🗺️ Tamanho do mapa corrigido');
                    }
                }, 100);

                // Carregar dados APENAS deste usuário
                await loadClientsFromSupabase();
                await loadBRDatabaseFromSupabase();
                await loadRouteDataFromSupabase();

                // Configurar sincronização em tempo real
                setupRealtimeSubscription();
            }

            console.log(`✅ Sessão iniciada com sucesso para ${state.currentUser.username}`);
        }

        // ========== GERENCIAMENTO DE USUÁRIOS (ADMIN) ==========

        // Listar usuários
        async function loadUsers() {
            if (!state.useSupabase || state.currentUser.role !== 'admin') return;

            try {
                const { data, error } = await supabase
                    .from('users')
                    .select('*')
                    .order('created_at', { ascending: false });

                if (error) throw error;

                const usersList = document.getElementById('usersList');
                if (!data || data.length === 0) {
                    usersList.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin-top: 40px;">Nenhum usuário cadastrado</p>';
                    return;
                }

                usersList.innerHTML = data.map(user => `
                    <div class="user-card">
                        <div class="user-info">
                            <h3>
                                ${user.name || user.username}
                                ${user.role === 'admin' ? '<span class="user-badge">ADMIN</span>' : ''}
                            </h3>
                            <p>Usuário: ${user.username} • ID: ${user.id} • Criado em ${new Date(user.created_at).toLocaleDateString('pt-BR')}</p>
                        </div>
                        <div class="user-actions">
                            <button class="btn btn-secondary" onclick="editUser(${user.id})">✏️ Editar</button>
                            <button class="btn btn-danger" onclick="deleteUser(${user.id}, '${user.username}')">🗑️ Excluir</button>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Erro ao carregar usuários:', error);
                showToast('Erro ao carregar usuários', 'error');
            }
        }

        // Auto-registro (sem necessidade de admin)
        async function registerUser(name, username, password) {
            if (!state.useSupabase) {
                showToast('Erro: Supabase não configurado', 'error');
                return false;
            }

            try {
                // CORREÇÃO: Verificar se usuário já existe (case-insensitive)
                const { data: existingUser } = await supabase
                    .from('users')
                    .select('username')
                    .ilike('username', username)
                    .single();

                if (existingUser) {
                    showToast('Erro: Já existe um usuário com esse nome. Escolha outro.', 'error');
                    return false;
                }

                // CORREÇÃO: Salvar username sempre em minúsculas para consistência
                const { data, error } = await supabase
                    .from('users')
                    .insert([{
                        username: username.toLowerCase(),
                        password,
                        role: 'user',
                        name: name  // Salvar nome completo
                    }])
                    .select();

                if (error) throw error;

                return true;

            } catch (error) {
                console.error('Erro ao criar conta:', error);

                if (error.code === '23505') {
                    showToast('Erro: Já existe um usuário com esse nome. Escolha outro.', 'error');
                } else if (error.message && error.message.includes('column "name"')) {
                    showToast('Erro: Execute o SQL para adicionar a coluna "name" na tabela users.', 'error');
                } else {
                    showToast('Erro ao criar conta. Tente novamente.', 'error');
                }
                return false;
            }
        }

        // Criar usuário (admin)
        async function createUser(name, username, password, role) {
            if (!state.useSupabase || state.currentUser.role !== 'admin') return;

            try {
                const { data, error } = await supabase
                    .from('users')
                    .insert([{ name, username, password, role }])
                    .select();

                if (error) throw error;

                showToast(`Usuário "${username}" criado com sucesso!`, 'success');
                await loadUsers();
                return true;

            } catch (error) {
                console.error('Erro ao criar usuário:', error);

                if (error.code === '23505') {
                    showToast('Erro: Já existe um usuário com esse nome', 'error');
                } else {
                    showToast('Erro ao criar usuário', 'error');
                }
                return false;
            }
        }

        // Editar usuário
        window.editUser = async function(userId) {
            try {
                const { data, error } = await supabase
                    .from('users')
                    .select('*')
                    .eq('id', userId)
                    .single();

                if (error) throw error;

                state.editingUserId = userId;
                document.getElementById('editUserName').value = data.name || '';
                document.getElementById('editUsername').value = data.username;
                document.getElementById('editUserPassword').value = '';
                document.getElementById('editUserRole').value = data.role || 'user';
                document.getElementById('editUserModal').classList.add('active');

            } catch (error) {
                console.error('Erro ao carregar usuário:', error);
                showToast('Erro ao carregar dados do usuário', 'error');
            }
        };

        // Atualizar usuário
        async function updateUser(userId, name, username, password, role) {
            if (!state.useSupabase || state.currentUser.role !== 'admin') return;

            try {
                const updateData = { name, username, role };
                if (password) {
                    updateData.password = password;
                }

                const { error } = await supabase
                    .from('users')
                    .update(updateData)
                    .eq('id', userId);

                if (error) throw error;

                showToast('Usuário atualizado com sucesso!', 'success');
                await loadUsers();
                return true;

            } catch (error) {
                console.error('Erro ao atualizar usuário:', error);
                showToast('Erro ao atualizar usuário', 'error');
                return false;
            }
        }

        // Deletar usuário
        window.deleteUser = async function(userId, username) {
            if (!state.useSupabase || state.currentUser.role !== 'admin') return;

            // Impedir que o admin exclua a si mesmo
            if (userId === state.currentUser.id) {
                showToast('Você não pode excluir seu próprio usuário!', 'error');
                return;
            }

            const confirmed = await customConfirm(
                `Tem certeza que deseja excluir o usuário "${username}"?\n\nTODOS os dados serão excluídos:\n- Endereços cadastrados\n- Planilhas carregadas\n- Todas as configurações\n\nEsta ação não pode ser desfeita!`,
                'Excluir Usuário e Todos os Dados'
            );

            if (!confirmed) {
                return;
            }

            try {
                console.log(`🗑️ Iniciando exclusão completa do usuário ${userId} (${username})...`);
                showToast('Excluindo usuário e todos os dados...', 'info');

                // 1. Contar e excluir todos os clientes (endereços) do usuário
                const { count: clientsCount } = await supabase
                    .from('clients')
                    .select('*', { count: 'exact', head: true })
                    .eq('user_id', userId);

                const { error: clientsError } = await supabase
                    .from('clients')
                    .delete()
                    .eq('user_id', userId);

                if (clientsError) {
                    console.error('Erro ao excluir clientes:', clientsError);
                    throw new Error(`Erro ao excluir endereços do usuário: ${clientsError.message}`);
                }
                console.log(`✅ ${clientsCount || 0} cliente(s)/endereço(s) do usuário ${userId} excluídos`);

                // 2. Contar e excluir todas as planilhas (br_addresses) do usuário
                const { count: brCount } = await supabase
                    .from('br_addresses')
                    .select('*', { count: 'exact', head: true })
                    .eq('user_id', userId);

                const { error: brError } = await supabase
                    .from('br_addresses')
                    .delete()
                    .eq('user_id', userId);

                if (brError) {
                    console.error('Erro ao excluir planilhas:', brError);
                    throw new Error(`Erro ao excluir planilhas do usuário: ${brError.message}`);
                }
                console.log(`✅ ${brCount || 0} código(s) BR de planilhas do usuário ${userId} excluídos`);

                // 3. Excluir o usuário
                const { error: userError } = await supabase
                    .from('users')
                    .delete()
                    .eq('id', userId);

                if (userError) {
                    console.error('Erro ao excluir usuário:', userError);
                    throw new Error(`Erro ao excluir usuário: ${userError.message}`);
                }
                console.log(`✅ Usuário ${userId} (${username}) excluído`);

                // Mensagem de sucesso com resumo
                const summary = `Usuário "${username}" excluído com sucesso!\n\n` +
                    `📊 Resumo:\n` +
                    `• ${clientsCount || 0} endereço(s)\n` +
                    `• ${brCount || 0} código(s) BR de planilhas`;

                showToast(summary, 'success');
                console.log(`\n=== EXCLUSÃO COMPLETA ===\nUsuário: ${username} (ID: ${userId})\nClientes: ${clientsCount || 0}\nPlanilhas: ${brCount || 0}\n========================\n`);

                await loadUsers();

            } catch (error) {
                console.error('Erro ao excluir usuário e dados:', error);
                showToast(error.message || 'Erro ao excluir usuário e dados', 'error');
            }
        };

        // Icons
        const currentLocationIcon = L.icon({
            iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" fill="#2563eb">
                    <circle cx="16" cy="16" r="14" fill="#3b82f6" stroke="white" stroke-width="3" opacity="0.3"/>
                    <circle cx="16" cy="16" r="10" fill="#3b82f6" stroke="white" stroke-width="3"/>
                    <circle cx="16" cy="16" r="5" fill="white"/>
                </svg>
            `),
            iconSize: [32, 32],
            iconAnchor: [16, 16]
        });

        const clientIcon = L.icon({
            iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#ef4444">
                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>
            `),
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            popupAnchor: [0, -32]
        });

        // Initialize Map
        async function initMap(lat, lng) {
            // Detectar mobile
            const isMobile = window.innerWidth <= 768;

            // Usar Canvas Renderer para melhor performance (especialmente em mobile)
            const renderer = L.canvas({ padding: 0.5 });

            state.map = L.map('map', {
                zoomControl: false,
                preferCanvas: true,  // Força uso de Canvas ao invés de SVG
                renderer: renderer,
                // Otimizações para mobile
                tap: true,
                tapTolerance: 15,
                bounceAtZoomLimits: false,
                // Manter animações suaves para melhor experiência
                zoomAnimation: true,
                fadeAnimation: true,
                markerZoomAnimation: true,
                // Configurações de zoom
                zoomSnap: 1,
                zoomDelta: 1,
                wheelPxPerZoomLevel: 60
            }).setView([lat, lng], isMobile ? 18 : 17);

            // Criar layers de Google Maps com tiles Retina (textos e ícones em tamanho normal do Google Maps)
            const googleStreets = L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}&scale=2', {
                attribution: '© Google Maps',
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                maxZoom: 21,
                minZoom: 3,
                updateWhenIdle: false,
                updateWhenZooming: true,
                keepBuffer: 2,
                tileSize: 256,
                zoomOffset: 0,
                className: ''
            });

            const googleSatellite = L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}&scale=2', {
                attribution: '© Google Maps',
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                maxZoom: 21,
                minZoom: 3,
                updateWhenIdle: false,
                updateWhenZooming: true,
                keepBuffer: 2,
                tileSize: 256,
                zoomOffset: 0,
                className: ''
            });

            const googleHybrid = L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}&scale=2', {
                attribution: '© Google Maps',
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                maxZoom: 21,
                minZoom: 3,
                updateWhenIdle: false,
                updateWhenZooming: true,
                keepBuffer: 2,
                tileSize: 256,
                zoomOffset: 0,
                className: ''
            });

            // Adicionar layer padrão (mapa de ruas)
            googleStreets.addTo(state.map);

            // Armazenar layers no estado para alternar depois
            state.mapLayers = {
                streets: googleStreets,
                satellite: googleSatellite,
                hybrid: googleHybrid
            };
            state.currentMapLayer = 'streets';

            // Add current location marker
            state.currentLocationMarker = L.marker([lat, lng], {
                icon: currentLocationIcon,
                title: 'Sua localização atual'
            }).addTo(state.map);

            // Bind popup mas NÃO abrir automaticamente (para evitar interferência com visualização de rotas)
            state.currentLocationMarker.bindPopup('<b>Você está aqui</b>');

            // Corrigir tamanho do mapa após inicialização (importante para quando container estava oculto)
            setTimeout(() => {
                if (state.map) {
                    state.map.invalidateSize();
                    console.log('🗺️ Tamanho do mapa ajustado após inicialização');
                }
            }, 200);

            // Load clients from Supabase
            await loadClientsFromSupabase();

            // Load BR database from Supabase
            await loadBRDatabaseFromSupabase();

            // Load route data from Supabase
            await loadRouteDataFromSupabase();

            // Configurar sincronização em tempo real
            setupRealtimeSubscription();

            hideLoading();
        }

        // Get Current Location
        async function getCurrentLocation() {
            if ('geolocation' in navigator) {
                // Verificar permissão antes de solicitar
                if (navigator.permissions) {
                    try {
                        const permission = await navigator.permissions.query({ name: 'geolocation' });
                        console.log('Permissão de geolocalização:', permission.state);
                    } catch (error) {
                        console.log('Não foi possível verificar permissão:', error);
                    }
                }

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        state.currentLocation = { lat, lng };
                        initMap(lat, lng);

                        // Watch position for updates (store ID to clear later if needed)
                        const backgroundWatchId = navigator.geolocation.watchPosition(
                            (pos) => {
                                const newLat = pos.coords.latitude;
                                const newLng = pos.coords.longitude;
                                state.currentLocation = { lat: newLat, lng: newLng };

                                if (state.currentLocationMarker) {
                                    state.currentLocationMarker.setLatLng([newLat, newLng]);
                                }
                            },
                            (error) => console.error('Error watching position:', error),
                            { enableHighAccuracy: true, maximumAge: 30000, timeout: 27000 }
                        );
                        // Note: backgroundWatchId is not stored to state as it should run continuously
                    },
                    (error) => {
                        console.error('Geolocation error:', error);

                        let errorMessage = 'Não foi possível obter sua localização.';
                        if (error.code === 1) {
                            errorMessage = 'Permissão de localização negada. Por favor, permita o acesso à localização nas configurações do navegador.';
                        }

                        // Default to São Paulo, Brazil
                        const defaultLat = -23.5505;
                        const defaultLng = -46.6333;
                        state.currentLocation = { lat: defaultLat, lng: defaultLng };
                        initMap(defaultLat, defaultLng);
                        showToast(errorMessage, 'warning');
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 30000 }
                );
            } else {
                showToast('Geolocalização não é suportada pelo seu navegador.', 'error');
                const defaultLat = -23.5505;
                const defaultLng = -46.6333;
                state.currentLocation = { lat: defaultLat, lng: defaultLng };
                initMap(defaultLat, defaultLng);
            }
        }

        // Show/Hide Loading
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Load BR Database from Supabase
        async function loadBRDatabaseFromSupabase() {
            if (!state.useSupabase || !state.currentUser) return;

            // Limpar mensagem imediatamente ao iniciar o carregamento
            const uploadStatus = document.getElementById('uploadStatus');
            if (uploadStatus) {
                uploadStatus.textContent = '';
                uploadStatus.className = 'upload-status';
            }

            try {
                const { data, error } = await supabase
                    .from('br_addresses')
                    .select('*')
                    .eq('user_id', state.currentUser.id);

                if (error) throw error;

                if (data && data.length > 0) {
                    state.brDatabase = {};
                    data.forEach(item => {
                        state.brDatabase[item.br_code] = item.address;
                    });
                    console.log(`✅ ${data.length} código(s) BR carregado(s) do Supabase (user_id: ${state.currentUser.id}) - ISOLAMENTO ATIVO`);

                    uploadStatus.textContent = `✓ ${data.length} códigos BR carregados!`;
                    uploadStatus.className = 'upload-status success';
                } else {
                    // Limpar mensagem se o usuário não tem dados
                    state.brDatabase = {};
                    uploadStatus.textContent = '';
                    uploadStatus.className = 'upload-status';
                    console.log(`📊 Nenhuma planilha encontrada para este usuário (user_id: ${state.currentUser.id})`);
                }
            } catch (error) {
                console.error('Erro ao carregar banco de dados BR:', error);
                // Limpar mensagem em caso de erro
                const uploadStatus = document.getElementById('uploadStatus');
                if (uploadStatus) {
                    uploadStatus.textContent = '';
                    uploadStatus.className = 'upload-status';
                }
                state.brDatabase = {};
                // Não mostra toast, pois pode ser que a tabela ainda não exista
            }
        }

        // Save BR Database to Supabase
        async function saveBRDatabaseToSupabase(brDatabase) {
            if (!state.useSupabase || !state.currentUser) return;

            try {
                // Limpar dados antigos APENAS deste usuário
                const { error: deleteError } = await supabase
                    .from('br_addresses')
                    .delete()
                    .eq('user_id', state.currentUser.id);

                if (deleteError) throw deleteError;

                // Inserir novos dados com user_id
                const records = Object.entries(brDatabase).map(([br_code, address]) => ({
                    br_code,
                    address,
                    user_id: state.currentUser.id
                }));

                if (records.length > 0) {
                    const { error: insertError } = await supabase
                        .from('br_addresses')
                        .insert(records);

                    if (insertError) throw insertError;

                    console.log(`✅ ${records.length} código(s) BR salvos no Supabase (user_id: ${state.currentUser.id})`);
                }
            } catch (error) {
                console.error('Erro ao salvar banco de dados BR:', error);
                showToast('Erro ao salvar códigos BR no banco de dados', 'error');
            }
        }

        // Salvar dados de roteirização no Supabase
        async function saveRouteDataToSupabase(routeData) {
            if (!state.useSupabase || !state.currentUser) return;

            try {
                // Limpar dados antigos APENAS deste usuário
                const { error: deleteError } = await supabase
                    .from('route_data')
                    .delete()
                    .eq('user_id', state.currentUser.id);

                if (deleteError) throw deleteError;

                // Inserir novos dados com user_id
                const records = routeData.map(item => ({
                    user_id: state.currentUser.id,
                    sequence: item.sequence,
                    stop: item.stop,
                    spx_tn: item.spxTn,
                    address: item.address,
                    address_original: item.addressOriginal,
                    address_cleaned: item.addressCleaned || '',
                    bairro: item.bairro || '',
                    city: item.city || '',
                    zipcode: item.zipcode || '',
                    latitude: item.latitude,
                    longitude: item.longitude,
                    geocoded_address: item.geocodedAddress || '',
                    packages: JSON.stringify(item.packages || [item.spxTn]),
                    sequences: JSON.stringify(item.sequences || [item.sequence]),
                    package_count: item.packageCount || 1
                }));

                if (records.length > 0) {
                    const { error: insertError } = await supabase
                        .from('route_data')
                        .insert(records);

                    if (insertError) throw insertError;

                    console.log(`✅ ${records.length} registro(s) de rota salvos no Supabase (user_id: ${state.currentUser.id})`);
                }
            } catch (error) {
                console.error('Erro ao salvar dados de rota:', error);
                showToast('Erro ao salvar dados de roteirização no banco de dados', 'error');
            }
        }

        // Carregar dados de roteirização do Supabase
        async function loadRouteDataFromSupabase() {
            if (!state.useSupabase || !state.currentUser) return;

            try {
                const { data, error } = await supabase
                    .from('route_data')
                    .select('*')
                    .eq('user_id', state.currentUser.id)
                    .order('sequence', { ascending: true });

                if (error) throw error;

                if (data && data.length > 0) {
                    state.routeData = data.map(item => ({
                        sequence: item.sequence,
                        stop: item.stop,
                        spxTn: item.spx_tn,
                        address: item.address,
                        addressOriginal: item.address_original,
                        addressCleaned: item.address_cleaned,
                        bairro: item.bairro,
                        city: item.city,
                        zipcode: item.zipcode,
                        latitude: item.latitude,
                        longitude: item.longitude,
                        geocodedAddress: item.geocoded_address,
                        packages: JSON.parse(item.packages || '[]'),
                        sequences: JSON.parse(item.sequences || '[]'),
                        packageCount: item.package_count
                    }));

                    console.log(`✅ ${state.routeData.length} registro(s) de rota carregados do Supabase`);

                    // Mostrar botão de roteirização se tiver dados
                    if (state.routeData.length > 0) {
                        document.getElementById('optimizeRouteBtn').style.display = 'block';
                        const totalPackages = state.routeData.reduce((sum, item) => sum + item.packageCount, 0);
                        const uploadStatus = document.getElementById('uploadStatus');
                        if (uploadStatus) {
                            uploadStatus.textContent = `✓ ${state.routeData.length} endereços, ${totalPackages} pacotes carregados`;
                            uploadStatus.className = 'upload-status success';
                        }

                        // Carregar status de entrega
                        await loadDeliveryStatusFromSupabase();

                        // Carregar e restaurar rota otimizada se existir
                        const optimizedRoute = await loadOptimizedRouteFromSupabase();
                        if (optimizedRoute && optimizedRoute.length > 0) {
                            // Restaurar a rota otimizada no mapa
                            setTimeout(() => {
                                processOptimizedRoute(optimizedRoute);
                                const routeStatus = document.getElementById('routeStatus');
                                if (routeStatus) {
                                    routeStatus.textContent = `✓ Rota otimizada restaurada! ${optimizedRoute.length} paradas.`;
                                    routeStatus.className = 'upload-status success';
                                }
                                console.log('✅ Rota otimizada restaurada automaticamente');
                            }, 500); // Aguardar mapa estar pronto
                        }
                    }
                } else {
                    state.routeData = [];
                    document.getElementById('optimizeRouteBtn').style.display = 'none';
                }
            } catch (error) {
                console.error('Erro ao carregar dados de rota:', error);
                state.routeData = [];
            }
        }

        // Salvar rota otimizada no Supabase
        async function saveOptimizedRouteToSupabase(optimizedOrder) {
            if (!state.useSupabase || !state.currentUser) return;

            try {
                // Limpar rotas otimizadas antigas APENAS deste usuário
                const { error: deleteError } = await supabase
                    .from('optimized_routes')
                    .delete()
                    .eq('user_id', state.currentUser.id);

                if (deleteError) throw deleteError;

                // Salvar nova rota otimizada
                const { error: insertError } = await supabase
                    .from('optimized_routes')
                    .insert([{
                        user_id: state.currentUser.id,
                        route_order: optimizedOrder,
                        total_stops: optimizedOrder.length
                    }]);

                if (insertError) throw insertError;

                console.log(`✅ Rota otimizada salva no Supabase (${optimizedOrder.length} paradas)`);
            } catch (error) {
                console.error('Erro ao salvar rota otimizada:', error);
                // Não mostrar erro para o usuário, apenas log
            }
        }

        // Carregar rota otimizada do Supabase
        async function loadOptimizedRouteFromSupabase() {
            if (!state.useSupabase || !state.currentUser) return null;

            try {
                const { data, error } = await supabase
                    .from('optimized_routes')
                    .select('*')
                    .eq('user_id', state.currentUser.id)
                    .order('created_at', { ascending: false })
                    .limit(1)
                    .single();

                if (error) {
                    if (error.code === 'PGRST116') {
                        // Nenhuma rota encontrada - normal
                        return null;
                    }
                    throw error;
                }

                if (data && data.route_order) {
                    console.log(`✅ Rota otimizada carregada do Supabase (${data.total_stops} paradas)`);
                    return data.route_order;
                }

                return null;
            } catch (error) {
                console.error('Erro ao carregar rota otimizada:', error);
                return null;
            }
        }

        // ========== SISTEMA DE STATUS DE ENTREGA ==========

        // Marcar parada como entregue
        async function markStopAsDelivered(stopIndex, stopData) {
            if (!state.useSupabase || !state.currentUser) {
                // Modo offline - apenas atualizar visualmente
                state.deliveredStops.add(stopIndex);
                updateRouteMarkers();
                showToast('✅ Parada marcada como entregue', 'success');
                return;
            }

            try {
                // Verificar se já existe registro
                const { data: existing, error: checkError } = await supabase
                    .from('delivery_status')
                    .select('*')
                    .eq('user_id', state.currentUser.id)
                    .eq('stop_index', stopIndex)
                    .single();

                if (checkError && checkError.code !== 'PGRST116') {
                    throw checkError;
                }

                if (existing) {
                    // Atualizar registro existente
                    const { error: updateError } = await supabase
                        .from('delivery_status')
                        .update({
                            is_delivered: true,
                            delivered_at: new Date().toISOString()
                        })
                        .eq('id', existing.id);

                    if (updateError) throw updateError;
                } else {
                    // Criar novo registro
                    const { error: insertError } = await supabase
                        .from('delivery_status')
                        .insert([{
                            user_id: state.currentUser.id,
                            stop_index: stopIndex,
                            stop_address: stopData.address,
                            stop_latitude: stopData.latitude,
                            stop_longitude: stopData.longitude,
                            is_delivered: true,
                            delivered_at: new Date().toISOString()
                        }]);

                    if (insertError) throw insertError;
                }

                // Atualizar estado local
                state.deliveredStops.add(stopIndex);
                updateRouteMarkers();
                updateDeliveryCounter(); // Atualizar contador
                showToast('✅ Parada marcada como entregue', 'success');
                console.log(`✅ Parada ${stopIndex} marcada como entregue no Supabase`);
            } catch (error) {
                console.error('Erro ao marcar parada como entregue:', error);
                showToast('Erro ao salvar status de entrega', 'error');
            }
        }

        // Desmarcar parada como entregue
        async function unmarkStopAsDelivered(stopIndex) {
            if (!state.useSupabase || !state.currentUser) {
                // Modo offline - apenas atualizar visualmente
                state.deliveredStops.delete(stopIndex);
                updateRouteMarkers();
                showToast('↩️ Entrega desfeita', 'info');
                return;
            }

            try {
                const { error } = await supabase
                    .from('delivery_status')
                    .update({
                        is_delivered: false,
                        delivered_at: null
                    })
                    .eq('user_id', state.currentUser.id)
                    .eq('stop_index', stopIndex);

                if (error) throw error;

                // Atualizar estado local
                state.deliveredStops.delete(stopIndex);
                updateRouteMarkers();
                updateDeliveryCounter(); // Atualizar contador
                showToast('↩️ Entrega desfeita', 'info');
                console.log(`↩️ Parada ${stopIndex} desmarcada no Supabase`);
            } catch (error) {
                console.error('Erro ao desmarcar parada:', error);
                showToast('Erro ao desfazer entrega', 'error');
            }
        }

        // Carregar status de entrega do Supabase
        async function loadDeliveryStatusFromSupabase() {
            if (!state.useSupabase || !state.currentUser) return;

            try {
                const { data, error } = await supabase
                    .from('delivery_status')
                    .select('*')
                    .eq('user_id', state.currentUser.id)
                    .eq('is_delivered', true);

                if (error) throw error;

                // Limpar estado anterior
                state.deliveredStops.clear();

                // Adicionar paradas entregues ao Set
                if (data && data.length > 0) {
                    data.forEach(delivery => {
                        state.deliveredStops.add(delivery.stop_index);
                    });
                    console.log(`✅ Status de entrega carregado: ${data.length} paradas entregues`);
                }
            } catch (error) {
                console.error('Erro ao carregar status de entrega:', error);
            }
        }

        // Limpar todos os status de entrega (quando iniciar nova rota)
        async function clearAllDeliveryStatus() {
            if (!state.useSupabase || !state.currentUser) {
                state.deliveredStops.clear();
                return;
            }

            try {
                const { error } = await supabase
                    .from('delivery_status')
                    .delete()
                    .eq('user_id', state.currentUser.id);

                if (error) throw error;

                state.deliveredStops.clear();
                console.log('🗑️ Status de entrega limpo');
            } catch (error) {
                console.error('Erro ao limpar status de entrega:', error);
            }
        }

        // Atualizar marcadores da rota após mudança de status de entrega
        function updateRouteMarkers() {
            if (!state.viewingOptimizedRoute || !state.optimizedOrder) return;

            // Re-renderizar a rota otimizada com os marcadores atualizados
            // Limpar marcadores e polylines anteriores
            state.routePolylines.forEach(polyline => state.map.removeLayer(polyline));
            state.routePolylines = [];

            // Usar a ordem otimizada armazenada no estado
            const optimizedOrder = state.optimizedOrder;
            const isMobile = window.innerWidth <= 768;
            const fixedColor = '#3b82f6'; // Azul fixo para todas as paradas
            const totalStops = optimizedOrder.length;
            const usePrettyIcons = !isMobile || totalStops <= 10;

            // Detectar e deslocar marcadores sobrepostos
            const offsetMap = new Map();
            const OVERLAP_THRESHOLD = 0.00005;
            const OFFSET_AMOUNT = 0.0001;

            function getAdjustedCoordinates(lat, lng, index) {
                let adjustedLat = lat;
                let adjustedLng = lng;

                for (const [key, offset] of offsetMap.entries()) {
                    const [existingLat, existingLng] = key.split('_').map(Number);
                    const latDiff = Math.abs(existingLat - adjustedLat);
                    const lngDiff = Math.abs(existingLng - adjustedLng);

                    if (latDiff < OVERLAP_THRESHOLD && lngDiff < OVERLAP_THRESHOLD) {
                        const angle = (offset.count * 60) * (Math.PI / 180);
                        adjustedLat = existingLat + (OFFSET_AMOUNT * Math.cos(angle));
                        adjustedLng = existingLng + (OFFSET_AMOUNT * Math.sin(angle));
                        offset.count++;
                        break;
                    }
                }

                const key = `${adjustedLat}_${adjustedLng}`;
                if (!offsetMap.has(key)) {
                    offsetMap.set(key, { count: 1 });
                }

                return [adjustedLat, adjustedLng];
            }

            // Reconstruir marcadores com status atualizado
            optimizedOrder.forEach((originalIndex, routeIndex) => {
                const stop = state.routeData[originalIndex];
                if (!stop || !stop.latitude || !stop.longitude) return;

                const [adjustedLat, adjustedLng] = getAdjustedCoordinates(
                    stop.latitude,
                    stop.longitude,
                    routeIndex
                );

                const stopNumber = routeIndex + 1;
                const isDelivered = state.deliveredStops.has(routeIndex);
                const color = isDelivered ? '#9ca3af' : fixedColor; // Cinza se entregue, azul se não
                const packageCount = stop.packageCount || 1;

                // Mobile com MUITAS paradas: usar CircleMarker simples
                if (isMobile && !usePrettyIcons) {
                    const circleMarker = L.circleMarker([adjustedLat, adjustedLng], {
                        radius: 12,
                        fillColor: color,
                        color: '#fff',
                        weight: 2,
                        opacity: isDelivered ? 0.6 : 1,
                        fillOpacity: isDelivered ? 0.5 : 0.9
                    }).addTo(state.map);

                    // CORREÇÃO: Não usar .openPopup() dentro do click handler - o Leaflet já abre o popup automaticamente
                    const createPopupContent = () => {
                        const sequencesList = stop.sequences && stop.sequences.length > 0
                            ? stop.sequences.sort((a, b) => a - b).join(', ')
                            : '-';
                        const currentlyDelivered = state.deliveredStops.has(routeIndex);

                        return `
                            <div style="font-size: 13px; min-width: 200px;">
                                <div style="font-weight: bold; margin-bottom: 6px; color: ${color};">
                                    ${currentlyDelivered ? '✅' : '🚚'} Parada ${stopNumber} • ${packageCount} pacote${packageCount > 1 ? 's' : ''}
                                </div>
                                <div style="margin: 3px 0;">📍 ${stop.address}</div>
                                <div style="margin: 3px 0; font-size: 11px; color: #666;">Ordem: ${sequencesList}</div>
                                ${!currentlyDelivered ? `
                                    <button onclick="markStopAsDelivered(${routeIndex}, ${JSON.stringify(stop).replace(/"/g, '&quot;')})"
                                        style="margin-top: 8px; width: 100%; padding: 8px; background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">
                                        ✅ Marcar como entregue
                                    </button>
                                ` : `
                                    <button onclick="unmarkStopAsDelivered(${routeIndex})"
                                        style="margin-top: 8px; width: 100%; padding: 8px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">
                                        ↩️ Desfazer entrega
                                    </button>
                                `}
                                <button onclick="startNavigationToStop(${stop.latitude}, ${stop.longitude}, '${stop.address.replace(/'/g, "\\'")}', ${stopNumber})"
                                    style="margin-top: 6px; width: 100%; padding: 8px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">
                                    🧭 Navegar até aqui
                                </button>
                            </div>
                        `;
                    };

                    // Bind popup inicial
                    circleMarker.bindPopup(createPopupContent());

                    // Atualizar conteúdo do popup quando aberto (para refletir mudanças de status)
                    circleMarker.on('click', function() {
                        this.setPopupContent(createPopupContent());
                    });

                    state.routePolylines.push(circleMarker);
                    return;
                }

                // PINO DE GPS com numeração
                const iconHTML = `
                    <div style="position: relative; width: 40px; height: ${packageCount > 1 ? '55px' : '40px'};">
                        ${packageCount > 1 ? `
                            <div style="
                                position: absolute;
                                top: -10px;
                                left: 50%;
                                transform: translateX(-50%);
                                background: #ef4444;
                                color: white;
                                border-radius: ${isMobile ? '8px' : '12px'};
                                padding: 2px ${isMobile ? '6px' : '8px'};
                                font-size: ${isMobile ? '10px' : '11px'};
                                font-weight: bold;
                                border: ${isMobile ? '1px' : '2px'} solid white;
                                box-shadow: ${isMobile ? '0 1px 3px rgba(0,0,0,0.3)' : '0 2px 6px rgba(0,0,0,0.3)'};
                                white-space: nowrap;
                                z-index: 10;
                            ">
                                ${packageCount} pacote${packageCount > 1 ? 's' : ''}
                            </div>
                        ` : ''}
                        <div style="
                            position: relative;
                            width: ${isMobile ? '32px' : '36px'};
                            height: ${isMobile ? '32px' : '36px'};
                            background: ${color};
                            border-radius: 50% 50% 50% 0;
                            border: ${isMobile ? '2px' : '3px'} solid white;
                            box-shadow: ${isMobile ? '0 2px 5px rgba(0,0,0,0.35)' : '0 3px 8px rgba(0,0,0,0.4)'};
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transform: rotate(-45deg);
                            margin: ${packageCount > 1 ? '18px' : '0'} auto 0 auto;
                            opacity: ${isDelivered ? '0.6' : '1'};
                        ">
                            <div style="
                                transform: rotate(45deg);
                                color: white;
                                font-weight: bold;
                                font-size: ${isMobile ? '13px' : '16px'};
                            ">
                                ${stopNumber}
                            </div>
                        </div>
                    </div>
                `;

                const numberedIcon = L.divIcon({
                    className: 'numbered-marker',
                    html: iconHTML,
                    iconSize: packageCount > 1 ? [40, 55] : [40, 40],
                    iconAnchor: packageCount > 1 ? [20, 55] : [20, 40]
                });

                const marker = L.marker([adjustedLat, adjustedLng], {
                    icon: numberedIcon,
                    title: `Parada ${stopNumber}: ${stop.address}`
                }).addTo(state.map);

                const sequencesList = stop.sequences && stop.sequences.length > 0
                    ? stop.sequences.sort((a, b) => a - b).join(', ')
                    : stop.sequence || '-';

                const packagesList = stop.packages && stop.packages.length > 0
                    ? (stop.packages.length <= (isMobile ? 5 : 10)
                        ? stop.packages.join(', ')
                        : `${stop.packages.slice(0, isMobile ? 5 : 10).join(', ')}... (+${stop.packages.length - (isMobile ? 5 : 10)})`)
                    : stop.spxTn || '-';

                const popupContent = isMobile ? `
                    <div class="popup-content" style="max-width: 250px;">
                        <h3 style="margin: 0 0 8px 0; font-size: 16px;">${isDelivered ? '✅' : '🚚'} Parada ${stopNumber}</h3>
                        <p style="margin: 4px 0;"><strong>📦 Pacotes:</strong> ${packageCount}</p>
                        <p style="margin: 4px 0;"><strong>🔢 Ordem:</strong> ${sequencesList}</p>
                        <p style="margin: 4px 0;"><strong>📍</strong> ${stop.address}</p>
                        ${stop.city ? `<p style="margin: 4px 0; font-size: 12px;"><strong>🏙️</strong> ${stop.city}</p>` : ''}
                        ${!isDelivered ? `
                            <button onclick="markStopAsDelivered(${routeIndex}, ${JSON.stringify(stop).replace(/"/g, '&quot;')})"
                                style="margin-top: 10px; width: 100%; padding: 10px; background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 13px;">
                                ✅ Marcar como entregue
                            </button>
                        ` : `
                            <button onclick="unmarkStopAsDelivered(${routeIndex})"
                                style="margin-top: 10px; width: 100%; padding: 10px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 13px;">
                                ↩️ Desfazer entrega
                            </button>
                        `}
                        <button onclick="startNavigationToStop(${stop.latitude}, ${stop.longitude}, '${stop.address.replace(/'/g, "\\'")}', ${stopNumber})"
                            style="margin-top: 6px; width: 100%; padding: 10px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 13px;">
                            🧭 Navegar até aqui
                        </button>
                    </div>
                ` : `
                    <div class="popup-content">
                        <h3>${isDelivered ? '✅' : '🚚'} Parada ${stopNumber}</h3>
                        ${distanceInfo}
                        <p><strong>📦 Pacotes:</strong> ${packageCount}</p>
                        <p><strong>🔢 Ordem:</strong><br><span style="font-size: 12px; color: #666;">${sequencesList}</span></p>
                        <p><strong>📍 Endereço:</strong><br>${stop.address}</p>
                        <p><strong>🏙️ Cidade:</strong> ${stop.city}</p>
                        <p><strong>📮 CEP:</strong> ${stop.zipcode}</p>
                        <p><strong>📦 Códigos SPX:</strong><br><span style="font-size: 11px; color: #666;">${packagesList}</span></p>
                        ${!isDelivered ? `
                            <button onclick="markStopAsDelivered(${routeIndex}, ${JSON.stringify(stop).replace(/"/g, '&quot;')})"
                                style="margin-top: 12px; width: 100%; padding: 10px; background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                ✅ Marcar como entregue
                            </button>
                        ` : `
                            <button onclick="unmarkStopAsDelivered(${routeIndex})"
                                style="margin-top: 12px; width: 100%; padding: 10px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                ↩️ Desfazer entrega
                            </button>
                        `}
                        <button onclick="startNavigationToStop(${stop.latitude}, ${stop.longitude}, '${stop.address.replace(/'/g, "\\'")}', ${stopNumber})"
                            style="margin-top: 8px; width: 100%; padding: 10px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            🧭 Navegar até aqui
                        </button>
                    </div>
                `;

                marker.bindPopup(popupContent);
                state.routePolylines.push(marker);

                // Desenhar linha para a próxima parada
                if (routeIndex < optimizedOrder.length - 1) {
                    const nextStop = state.routeData[optimizedOrder[routeIndex + 1]];
                    if (nextStop && nextStop.latitude && nextStop.longitude) {
                        const polyline = L.polyline([
                            [stop.latitude, stop.longitude],
                            [nextStop.latitude, nextStop.longitude]
                        ], {
                            color: color,
                            weight: 3,
                            opacity: 0.7,
                            dashArray: '10, 5'
                        }).addTo(state.map);

                        state.routePolylines.push(polyline);
                    }
                }
            });

            console.log('🔄 Marcadores da rota atualizados');
        }

        // Configurar sincronização automática com POLLING (mais confiável)
        function setupRealtimeSubscription() {
            if (!state.useSupabase || !state.currentUser) return;

            // Cancelar polling anterior se existir
            if (state.syncPollingInterval) {
                clearInterval(state.syncPollingInterval);
                state.syncPollingInterval = null;
            }

            console.log(`🔄 Configurando sincronização automática (polling) para user_id: ${state.currentUser.id}`);

            // Verificar mudanças a cada 0.5 segundos (ultra-rápido)
            state.syncPollingInterval = setInterval(async () => {
                await checkForClientChanges();
            }, 500); // 0.5 segundos

            console.log('✅ Sincronização automática ativada! (verificando a cada 0.5s)');
        }

        // ========== CONTROLES DO MAPA (AMAZON FLEX STYLE) ==========

        // Alternar tipo de mapa (Rua/Satélite/Híbrido)
        function toggleMapType() {
            if (!state.map || !state.mapLayers) return;

            const types = ['streets', 'satellite', 'hybrid'];
            const labels = ['Satélite', 'Híbrido', 'Mapa'];
            const currentIndex = types.indexOf(state.currentMapLayer);
            const nextIndex = (currentIndex + 1) % types.length;
            const nextType = types[nextIndex];

            // Remover layer atual
            state.map.removeLayer(state.mapLayers[state.currentMapLayer]);

            // Adicionar novo layer
            state.mapLayers[nextType].addTo(state.map);

            // Atualizar estado e UI
            state.currentMapLayer = nextType;
            document.getElementById('mapTypeLabel').textContent = labels[nextIndex];

            console.log(`🗺️ Mapa alterado para: ${nextType}`);
        }

        // Recentralizar mapa na localização atual do GPS
        function recenterMap() {
            if (!state.map || !state.currentLocationMarker) {
                showToast('Localização GPS não disponível', 'error');
                return;
            }

            const latlng = state.currentLocationMarker.getLatLng();
            state.map.setView(latlng, 18, {
                animate: true,
                duration: 0.5
            });

            // Efeito visual no botão
            const btn = document.getElementById('recenterBtn');
            btn.style.transform = 'scale(0.9) rotate(180deg)';
            setTimeout(() => {
                btn.style.transform = 'scale(1) rotate(0deg)';
            }, 300);

            showToast('📍 Centralizado na sua localização', 'success');
        }

        // Atualizar contador de entregas
        function updateDeliveryCounter() {
            if (!state.optimizedOrder) {
                document.getElementById('deliveryCounter').style.display = 'none';
                return;
            }

            const total = state.optimizedOrder.length;
            const delivered = state.deliveredStops.size;
            const percentage = total > 0 ? (delivered / total) * 100 : 0;

            document.getElementById('deliveryCounter').style.display = 'block';
            document.getElementById('deliveredCount').textContent = delivered;
            document.getElementById('totalCount').textContent = total;
            document.getElementById('deliveryProgress').style.width = `${percentage}%`;
        }

        // Calcular tempo estimado (baseado em velocidade média de 30 km/h em cidade)
        function calculateEstimatedTime(distanceKm) {
            const avgSpeed = 30; // km/h
            const hours = distanceKm / avgSpeed;
            const minutes = Math.round(hours * 60);

            if (minutes < 1) return '< 1 min';
            if (minutes < 60) return `${minutes} min`;
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            return `${h}h ${m}min`;
        }

        // Formatar distância
        function formatDistance(distanceKm) {
            if (distanceKm < 1) {
                return `${Math.round(distanceKm * 1000)} m`;
            }
            return `${distanceKm.toFixed(1)} km`;
        }

        // Verificar mudanças nos clientes
        async function checkForClientChanges() {
            if (!state.useSupabase || !state.currentUser) return;

            try {
                // Buscar clientes do servidor
                const { data, error } = await supabase
                    .from('clients')
                    .select('*')
                    .eq('user_id', state.currentUser.id)
                    .order('created_at', { ascending: false });

                if (error) throw error;

                const serverClients = data || [];

                // Converter para formato do cliente
                const serverClientsMap = {};
                serverClients.forEach(client => {
                    serverClientsMap[client.id] = {
                        id: client.id,
                        name: client.name,
                        address: client.address,
                        lat: client.latitude,
                        lng: client.longitude,
                        br: client.br || '',
                        phone: client.phone || '',
                        date: client.created_at
                    };
                });

                // IDs dos clientes locais e do servidor
                const localIds = new Set(state.clients.map(c => c.id));
                const serverIds = new Set(serverClients.map(c => c.id));

                // Detectar NOVOS clientes (no servidor mas não local)
                serverIds.forEach(id => {
                    if (!localIds.has(id)) {
                        const newClient = serverClientsMap[id];
                        state.clients.push(newClient);
                        addClientMarker(newClient);
                        updateClientsList();
                        showToast(`✨ Novo cliente: ${newClient.name}`, 'success');
                        console.log('✅ Cliente adicionado via sync:', newClient.name);
                    }
                });

                // Detectar clientes REMOVIDOS (local mas não no servidor)
                const clientsToRemove = [];
                state.clients.forEach((client, index) => {
                    if (!serverIds.has(client.id)) {
                        clientsToRemove.push({ client, index });
                    }
                });

                // Remover clientes deletados (do fim para o início)
                clientsToRemove.reverse().forEach(({ client, index }) => {
                    // Remover do state
                    state.clients.splice(index, 1);

                    // Remover marcador do mapa
                    const markerObj = state.clientMarkers.find(m => m.id === client.id);
                    if (markerObj && state.map) {
                        state.map.removeLayer(markerObj.marker);
                        const markerIndex = state.clientMarkers.findIndex(m => m.id === client.id);
                        if (markerIndex !== -1) {
                            state.clientMarkers.splice(markerIndex, 1);
                        }
                    }

                    updateClientsList();
                    showToast(`🗑️ Cliente removido: ${client.name}`, 'warning');
                    console.log('🗑️ Cliente deletado via sync:', client.name);
                });

                // Detectar clientes ATUALIZADOS
                state.clients.forEach((localClient, index) => {
                    if (serverIds.has(localClient.id)) {
                        const serverClient = serverClientsMap[localClient.id];

                        // Verificar se houve mudanças
                        const hasChanges =
                            localClient.name !== serverClient.name ||
                            localClient.address !== serverClient.address ||
                            localClient.lat !== serverClient.lat ||
                            localClient.lng !== serverClient.lng ||
                            localClient.br !== serverClient.br ||
                            localClient.phone !== serverClient.phone;

                        if (hasChanges) {
                            // Atualizar no state
                            state.clients[index] = serverClient;

                            // Atualizar marcador no mapa
                            const markerObj = state.clientMarkers.find(m => m.id === serverClient.id);
                            if (markerObj && state.map) {
                                state.map.removeLayer(markerObj.marker);
                                const markerIndex = state.clientMarkers.findIndex(m => m.id === serverClient.id);
                                if (markerIndex !== -1) {
                                    state.clientMarkers.splice(markerIndex, 1);
                                }
                                addClientMarker(serverClient);
                            }

                            updateClientsList();
                            showToast(`🔄 Cliente atualizado: ${serverClient.name}`, 'info');
                            console.log('🔄 Cliente atualizado via sync:', serverClient.name);
                        }
                    }
                });

            } catch (error) {
                // Silencioso - não mostrar erro para o usuário (polling em background)
                console.error('Erro na sincronização automática:', error);
            }
        }

        // Load Clients from Supabase
        async function loadClientsFromSupabase() {
            if (!state.useSupabase || !state.currentUser) return;

            try {
                const { data, error } = await supabase
                    .from('clients')
                    .select('*')
                    .eq('user_id', state.currentUser.id)
                    .order('created_at', { ascending: false });

                if (error) throw error;

                if (data && data.length > 0) {
                    // Clear existing clients
                    state.clients = [];
                    state.clientMarkers.forEach(m => state.map.removeLayer(m.marker));
                    state.clientMarkers = [];

                    // Add clients from database
                    data.forEach(client => {
                        const clientObj = {
                            id: client.id,
                            name: client.name,
                            address: client.address,
                            lat: client.latitude,
                            lng: client.longitude,
                            br: client.br || '',
                            phone: client.phone || '',
                            date: client.created_at
                        };
                        state.clients.push(clientObj);
                        addClientMarker(clientObj);
                    });

                    updateClientsList();
                    console.log(`✅ ${data.length} cliente(s) carregado(s) do Supabase (user_id: ${state.currentUser.id}) - ISOLAMENTO ATIVO`);
                }
            } catch (error) {
                console.error('Erro ao carregar clientes:', error);
                showToast('Erro ao carregar clientes do banco de dados', 'error');
            }
        }

        // Add Client
        async function addClient(name, address, lat, lng, br = '', phone = '') {
            // Verificar se o usuário está logado
            if (!state.currentUser || !state.currentUser.id) {
                showToast('Erro: Usuário não autenticado', 'error');
                return;
            }

            const client = {
                name,
                address,
                lat,
                lng,
                br,
                phone,
                date: new Date().toISOString()
            };

            if (state.useSupabase) {
                try {
                    const { data, error } = await supabase
                        .from('clients')
                        .insert([
                            {
                                name: client.name,
                                address: client.address,
                                latitude: client.lat,
                                longitude: client.lng,
                                br: client.br,
                                phone: client.phone,
                                user_id: state.currentUser.id
                            }
                        ])
                        .select();

                    if (error) throw error;

                    // Use the ID from database
                    client.id = data[0].id;
                    client.date = data[0].created_at;
                    client.br = data[0].br || '';
                    client.phone = data[0].phone || '';

                    console.log(`✅ Cliente salvo no Supabase (user_id: ${state.currentUser.id})`);
                } catch (error) {
                    console.error('Erro ao salvar cliente:', error);

                    // Mensagens de erro específicas
                    let errorMessage = 'Erro ao salvar cliente no banco de dados';

                    if (error.message && error.message.includes('column "phone"')) {
                        errorMessage = 'Erro: A coluna "phone" não existe no banco de dados. Execute este SQL no Supabase:\nALTER TABLE clients ADD COLUMN phone TEXT;';
                    } else if (error.code === '42703') {
                        errorMessage = 'Erro: Coluna não encontrada no banco de dados. Verifique a estrutura da tabela "clients" no Supabase.';
                    } else if (error.code === '23505') {
                        errorMessage = 'Erro: Cliente duplicado. Já existe um cliente com esses dados.';
                    } else if (error.message) {
                        errorMessage = `Erro ao salvar: ${error.message}`;
                    }

                    showToast(errorMessage, 'error');
                    console.error('💡 Detalhes do erro:', {
                        code: error.code,
                        message: error.message,
                        details: error.details,
                        hint: error.hint
                    });
                    return null;
                }
            } else {
                // Fallback to local storage
                client.id = state.nextId++;
            }

            state.clients.push(client);
            addClientMarker(client);
            updateClientsList();
            return client;
        }

        // Add Client Marker
        function addClientMarker(client) {
            const marker = L.marker([client.lat, client.lng], {
                icon: clientIcon,
                title: client.name
            }).addTo(state.map);

            updateMarkerPopup(client, marker);
            state.clientMarkers.push({ id: client.id, marker });
        }

        // Calculate Distance between two points (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Raio da Terra em km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distância em km
        }

        // Update Navigation Stats
        function updateNavigationStats() {
            if (!state.navigationActive || !state.currentLocation || !state.navigationDestination) return;

            const distance = calculateDistance(
                state.currentLocation.lat,
                state.currentLocation.lng,
                state.navigationDestination.lat,
                state.navigationDestination.lng
            );

            // Atualizar painel
            document.getElementById('navDistance').textContent =
                distance < 1 ? `${Math.round(distance * 1000)} m` : `${distance.toFixed(2)} km`;

            // Estimativa de tempo (assumindo 40 km/h de média)
            const estimatedTime = Math.round((distance / 40) * 60);
            document.getElementById('navTime').textContent =
                estimatedTime < 1 ? '< 1 min' : `${estimatedTime} min`;

            // Verificar se chegou ao destino (menos de 50 metros)
            if (distance < 0.05) {
                showToast('🎉 Você chegou ao destino!', 'success');
                stopRealtimeNavigation();
            }
        }

        // Start GPS Tracking for real-time navigation
        function startGPSTracking() {
            if (!('geolocation' in navigator)) {
                showToast('Geolocalização não suportada', 'error');
                return;
            }

            let lastLat = null;
            let lastLng = null;
            let gpsErrorCount = 0; // Contador de erros consecutivos
            const MAX_GPS_ERRORS = 3; // Máximo de erros antes de tentar reconectar

            // Função para iniciar/reiniciar watchPosition
            const startGPSTracking = () => {
                // Limpar watch anterior se existir
                if (state.navigationWatchId) {
                    navigator.geolocation.clearWatch(state.navigationWatchId);
                    state.navigationWatchId = null;
                }

                console.log('🛰️ Iniciando rastreamento GPS...');

                // Rastrear posição continuamente
                state.navigationWatchId = navigator.geolocation.watchPosition(
                    (position) => {
                        // ✅ SUCESSO - resetar contador de erros
                        gpsErrorCount = 0;

                        const newLat = position.coords.latitude;
                        const newLng = position.coords.longitude;
                        const heading = position.coords.heading; // Direção do movimento (0-360 graus)
                        const speed = position.coords.speed; // Velocidade em m/s

                        console.log('📍 Posição atualizada:', {
                            lat: newLat,
                            lng: newLng,
                            heading: heading,
                            speed: speed
                        });

                        // Atualizar posição atual
                        state.currentLocation = { lat: newLat, lng: newLng };

                        // Atualizar marcador de posição no mapa
                        if (state.currentLocationMarker) {
                            state.currentLocationMarker.setLatLng([newLat, newLng]);
                        }

                        // Calcular direção baseado na posição anterior se heading não estiver disponível
                        let bearing = heading;
                        if (bearing === null && lastLat !== null && lastLng !== null) {
                            // Calcular bearing entre dois pontos
                            const dLon = (newLng - lastLng) * Math.PI / 180;
                            const lat1 = lastLat * Math.PI / 180;
                            const lat2 = newLat * Math.PI / 180;
                            const y = Math.sin(dLon) * Math.cos(lat2);
                            const x = Math.cos(lat1) * Math.sin(lat2) -
                                    Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
                            bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
                        }

                        // ROTAÇÃO DO MAPA baseado na direção do movimento
                        // Nota: setBearing() requer plugin Leaflet.Rotate - comentado por enquanto
                        if (bearing !== null && !isNaN(bearing)) {
                            // state.map.setBearing(bearing);
                            console.log('🧭 Direção calculada:', bearing.toFixed(1) + '°');
                        }

                        // Calcular distância até o destino
                        const distanceToDestination = calculateDistance(
                            newLat, newLng,
                            state.navigationDestination.lat, state.navigationDestination.lng
                        );

                        // ZOOM DINÂMICO baseado na distância (APENAS durante navegação ativa E não visualizando rota otimizada)
                        if (state.navigationActive && !state.viewingOptimizedRoute) {
                            let targetZoom = 16; // Zoom padrão
                            if (distanceToDestination < 0.1) { // Menos de 100m
                                targetZoom = 19; // Zoom alto (próximo)
                            } else if (distanceToDestination < 0.5) { // Menos de 500m
                                targetZoom = 18;
                            } else if (distanceToDestination < 1) { // Menos de 1km
                                targetZoom = 17;
                            } else if (distanceToDestination < 5) { // Menos de 5km
                                targetZoom = 16;
                            } else {
                                targetZoom = 14; // Zoom médio (longe)
                            }

                            // Aplicar zoom suave
                            if (Math.abs(state.map.getZoom() - targetZoom) > 0.5) {
                                state.map.setZoom(targetZoom, {
                                    animate: true
                                });
                                console.log(`🔍 Zoom ajustado para ${targetZoom} (distância: ${distanceToDestination.toFixed(2)} km)`);
                            }
                        }

                        // Centralizar mapa na posição atual APENAS se navegação estiver ativa E não visualizando rota otimizada
                        if (state.navigationActive && !state.viewingOptimizedRoute) {
                            state.map.panTo([newLat, newLng], {
                                animate: true,
                                duration: 1
                            });
                        }

                        // Atualizar estatísticas de navegação
                        updateNavigationStats();

                        // Recalcular rota se necessário
                        if (state.routingControl && state.navigationDestination) {
                            const waypoints = state.routingControl.getWaypoints();
                            waypoints[0].latLng = L.latLng(newLat, newLng);
                            state.routingControl.setWaypoints(waypoints);
                        }

                        // Armazenar posição atual para próxima iteração
                        lastLat = newLat;
                        lastLng = newLng;
                    },
                    (error) => {
                        gpsErrorCount++;
                        console.error(`❌ Erro no rastreamento GPS (${gpsErrorCount}/${MAX_GPS_ERRORS}):`, error.code, error.message);

                        // Identificar tipo de erro
                        let errorMsg = 'Erro ao rastrear localização';
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMsg = 'Permissão de localização negada';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMsg = 'Sinal GPS fraco ou indisponível';
                                break;
                            case error.TIMEOUT:
                                errorMsg = 'Tempo esgotado ao obter localização';
                                break;
                        }

                        // Mostrar aviso
                        showToast(errorMsg, 'warning');

                        // RECONEXÃO AUTOMÁTICA após múltiplos erros
                        if (gpsErrorCount >= MAX_GPS_ERRORS && state.navigationActive) {
                            console.warn(`🔄 Tentando reconectar GPS após ${MAX_GPS_ERRORS} erros...`);
                            gpsErrorCount = 0; // Resetar contador

                            // Aguardar 2 segundos e tentar reconectar
                            setTimeout(() => {
                                if (state.navigationActive) { // Verificar se navegação ainda está ativa
                                    console.log('🔄 Reiniciando rastreamento GPS...');
                                    showToast('Reconectando GPS...', 'info');
                                    startGPSTracking();
                                }
                            }, 2000);
                        }
                    },
                    {
                        enableHighAccuracy: true,
                        maximumAge: 2000, // Aceitar posições de até 2 segundos atrás
                        timeout: 30000 // ⬆️ AUMENTADO: 30 segundos (era 10s)
                    }
                );

                console.log('✅ Rastreamento GPS iniciado com rotação e zoom automático');
            };

            // Iniciar rastreamento
            startGPSTracking();
        }

        // Toggle Navigation Panel
        window.toggleNavigationPanel = function() {
            const navPanel = document.getElementById('navigationPanel');
            const toggleBtn = document.getElementById('navToggleBtn');

            if (navPanel.classList.contains('collapsed')) {
                navPanel.classList.remove('collapsed');
                toggleBtn.textContent = 'Ocultar';
            } else {
                navPanel.classList.add('collapsed');
                toggleBtn.textContent = 'Ver';
            }
        };

        // Stop Realtime Navigation
        window.stopRealtimeNavigation = function() {
            state.navigationActive = false;

            // Parar rastreamento GPS
            if (state.navigationWatchId) {
                navigator.geolocation.clearWatch(state.navigationWatchId);
                state.navigationWatchId = null;
            }

            // Remover rota
            if (state.routingControl) {
                state.map.removeControl(state.routingControl);
                state.routingControl = null;
            }

            // NÃO resetar zoom aqui - deixar o mapa onde está
            // (o zoom será ajustado por quem chamou esta função, se necessário)

            // Ocultar painel
            const navPanel = document.getElementById('navigationPanel');
            if (navPanel) {
                navPanel.classList.remove('active');
            }

            state.navigationDestination = null;
            state.currentRoute = null;
        };

        // Start Navigation with Real-time GPS
        window.startNavigation = function(clientId) {
            const client = state.clients.find(c => c.id === clientId);
            if (!client || !state.currentLocation) return;

            // Parar navegação anterior se houver
            if (state.navigationActive) {
                stopRealtimeNavigation();
            }

            // Desabilitar modo de visualização de rota otimizada
            state.viewingOptimizedRoute = false;

            // Fechar todos os popups
            state.map.closePopup();

            // Configurar nova navegação
            state.navigationActive = true;
            state.navigationDestination = {
                lat: client.lat,
                lng: client.lng,
                name: client.name
            };

            // Mostrar painel de navegação
            document.getElementById('navigationPanel').classList.add('active');
            document.getElementById('navDestination').textContent = client.name;
            document.getElementById('navStatus').textContent = '📡 Calculando rota...';
            document.getElementById('navStatus').className = 'nav-status calculating';

            console.log('🧭 Iniciando navegação em tempo real:', {
                origem: `${state.currentLocation.lat}, ${state.currentLocation.lng}`,
                destino: `${client.lat}, ${client.lng}`,
                cliente: client.name
            });

            try {
                // Criar controle de roteamento
                state.routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(state.currentLocation.lat, state.currentLocation.lng),
                        L.latLng(client.lat, client.lng)
                    ],
                    routeWhileDragging: false,
                    showAlternatives: false,
                    addWaypoints: false,
                    fitSelectedRoutes: true,
                    lineOptions: {
                        styles: [
                            {color: '#2563eb', opacity: 0.8, weight: 6}
                        ],
                        extendToWaypoints: true,
                        missingRouteTolerance: 0
                    },
                    createMarker: function() { return null; }, // Não criar marcadores extras
                    router: L.Routing.osrmv1({
                        serviceUrl: 'https://router.project-osrm.org/route/v1',
                        profile: 'driving', // ou 'car', 'bike', 'foot'
                        timeout: 30000 // 30 segundos timeout
                    }),
                    formatter: new L.Routing.Formatter({
                        language: 'pt',
                        units: 'metric',
                        unitNames: {
                            meters: 'm',
                            kilometers: 'km',
                            yards: 'yd',
                            miles: 'mi',
                            hours: 'h',
                            minutes: 'min',
                            seconds: 's'
                        }
                    })
                }).addTo(state.map);

                // Evento quando a rota é calculada
                state.routingControl.on('routesfound', function(e) {
                    console.log('✅ Rota encontrada:', e.routes);
                    const routes = e.routes;
                    state.currentRoute = routes[0];
                    const summary = routes[0].summary;
                    const distance = (summary.totalDistance / 1000).toFixed(2);
                    const time = Math.round(summary.totalTime / 60);

                    // Atualizar painel com dados da rota
                    document.getElementById('navDistance').textContent = `${distance} km`;
                    document.getElementById('navTime').textContent = `${time} min`;
                    document.getElementById('navStatus').textContent = '🚗 Navegando...';
                    document.getElementById('navStatus').className = 'nav-status';

                    // ZOOM INICIAL mais próximo baseado na distância
                    let initialZoom = 19; // Zoom muito alto por padrão
                    const distKm = parseFloat(distance);
                    if (distKm < 0.5) { // Menos de 500m
                        initialZoom = 19;
                    } else if (distKm < 2) { // Menos de 2km
                        initialZoom = 18;
                    } else if (distKm < 5) { // Menos de 5km
                        initialZoom = 17;
                    } else if (distKm < 10) { // Menos de 10km
                        initialZoom = 16;
                    } else {
                        initialZoom = 15;
                    }

                    // Aplicar zoom inicial
                    state.map.setZoom(initialZoom);
                    console.log(`🔍 Zoom inicial definido para ${initialZoom} (distância: ${distance} km)`);

                    // Centralizar no ponto inicial (sua localização)
                    state.map.setView([state.currentLocation.lat, state.currentLocation.lng], initialZoom, {
                        animate: true,
                        duration: 0.5
                    });

                    // Iniciar rastreamento GPS em tempo real
                    startGPSTracking();

                    // Fechar sidebar em mobile
                    if (window.innerWidth <= 768) {
                        document.getElementById('sidebar').classList.remove('open');
                    }
                });

                state.routingControl.on('routingerror', function(e) {
                    console.error('❌ Erro detalhado ao calcular rota:', e);

                    let errorMsg = 'Não foi possível calcular a rota.';

                    if (e.error && e.error.status) {
                        if (e.error.status === 429) {
                            errorMsg = 'Muitas requisições. Aguarde alguns segundos e tente novamente.';
                        } else if (e.error.status === 0) {
                            errorMsg = 'Sem conexão com o servidor de rotas. Verifique sua internet.';
                        } else {
                            errorMsg = `Erro ${e.error.status}: ${e.error.message || 'Erro desconhecido'}`;
                        }
                    }

                    showToast(errorMsg, 'error');

                    // Remover controle com erro
                    if (state.routingControl) {
                        state.map.removeControl(state.routingControl);
                        state.routingControl = null;
                    }
                });

            } catch (error) {
                console.error('❌ Erro ao criar roteamento:', error);
                showToast('Erro ao iniciar navegação: ' + error.message, 'error');
            }
        };

        // Start Navigation to a Stop (from optimized route)
        window.startNavigationToStop = function(lat, lng, address, stopNumber) {
            if (!state.currentLocation) {
                showToast('Localização atual não disponível', 'error');
                return;
            }

            // Parar navegação anterior se houver
            if (state.navigationActive) {
                stopRealtimeNavigation();
            }

            // Desabilitar modo de visualização de rota otimizada
            state.viewingOptimizedRoute = false;

            // Fechar todos os popups
            state.map.closePopup();

            // Configurar nova navegação
            state.navigationActive = true;
            state.navigationDestination = {
                lat: lat,
                lng: lng,
                name: `Parada ${stopNumber}: ${address}`
            };

            // Mostrar painel de navegação
            document.getElementById('navigationPanel').classList.add('active');
            document.getElementById('navDestination').textContent = `Parada ${stopNumber}`;
            document.getElementById('navStatus').textContent = '📡 Calculando rota...';
            document.getElementById('navStatus').className = 'nav-status calculating';

            console.log('🧭 Iniciando navegação para parada:', {
                origem: `${state.currentLocation.lat}, ${state.currentLocation.lng}`,
                destino: `${lat}, ${lng}`,
                parada: stopNumber,
                endereco: address
            });

            try {
                // Criar controle de roteamento
                state.routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(state.currentLocation.lat, state.currentLocation.lng),
                        L.latLng(lat, lng)
                    ],
                    routeWhileDragging: false,
                    showAlternatives: false,
                    addWaypoints: false,
                    fitSelectedRoutes: true,
                    lineOptions: {
                        styles: [
                            {color: '#2563eb', opacity: 0.8, weight: 6}
                        ],
                        extendToWaypoints: true,
                        missingRouteTolerance: 0
                    },
                    createMarker: function() { return null; },
                    router: L.Routing.osrmv1({
                        serviceUrl: 'https://router.project-osrm.org/route/v1',
                        profile: 'driving',
                        timeout: 30000
                    }),
                    formatter: new L.Routing.Formatter({
                        language: 'pt',
                        units: 'metric',
                        unitNames: {
                            meters: 'm',
                            kilometers: 'km',
                            yards: 'yd',
                            miles: 'mi',
                            hours: 'h',
                            minutes: 'min',
                            seconds: 's'
                        }
                    })
                }).addTo(state.map);

                // Evento quando a rota é calculada
                state.routingControl.on('routesfound', function(e) {
                    console.log('✅ Rota encontrada:', e.routes);
                    const routes = e.routes;
                    state.currentRoute = routes[0];
                    const summary = routes[0].summary;
                    const distance = (summary.totalDistance / 1000).toFixed(2);
                    const time = Math.round(summary.totalTime / 60);

                    // Atualizar painel com dados da rota
                    document.getElementById('navDistance').textContent = `${distance} km`;
                    document.getElementById('navTime').textContent = `${time} min`;
                    document.getElementById('navStatus').textContent = '🚗 Navegando...';
                    document.getElementById('navStatus').className = 'nav-status';

                    // ZOOM INICIAL mais próximo baseado na distância
                    let initialZoom = 19;
                    const distKm = parseFloat(distance);
                    if (distKm < 0.5) {
                        initialZoom = 19;
                    } else if (distKm < 2) {
                        initialZoom = 18;
                    } else if (distKm < 5) {
                        initialZoom = 17;
                    } else if (distKm < 10) {
                        initialZoom = 16;
                    } else {
                        initialZoom = 15;
                    }

                    // Aplicar zoom inicial
                    state.map.setZoom(initialZoom);
                    console.log(`🔍 Zoom inicial definido para ${initialZoom} (distância: ${distance} km)`);

                    // Centralizar no ponto inicial (sua localização)
                    state.map.setView([state.currentLocation.lat, state.currentLocation.lng], initialZoom, {
                        animate: true,
                        duration: 0.5
                    });

                    // Iniciar rastreamento GPS em tempo real
                    startGPSTracking();

                    // Fechar sidebar em mobile
                    if (window.innerWidth <= 768) {
                        document.getElementById('sidebar').classList.remove('open');
                    }
                });

                state.routingControl.on('routingerror', function(e) {
                    console.error('❌ Erro detalhado ao calcular rota:', e);

                    let errorMsg = 'Não foi possível calcular a rota.';

                    if (e.error && e.error.status) {
                        if (e.error.status === 400) {
                            errorMsg = 'Coordenadas inválidas. Verifique o endereço.';
                        } else if (e.error.status === 404) {
                            errorMsg = 'Não foi possível encontrar uma rota entre os pontos.';
                        } else if (e.error.status >= 500) {
                            errorMsg = 'Erro no servidor de rotas. Tente novamente.';
                        }
                    }

                    document.getElementById('navStatus').textContent = '❌ ' + errorMsg;
                    document.getElementById('navStatus').className = 'nav-status error';
                    showToast(errorMsg, 'error');

                    // Remover controle de roteamento em caso de erro
                    if (state.routingControl) {
                        state.map.removeControl(state.routingControl);
                        state.routingControl = null;
                    }
                    state.navigationActive = false;
                });

            } catch (error) {
                console.error('❌ Erro ao criar roteamento:', error);
                showToast('Erro ao iniciar navegação: ' + error.message, 'error');
            }
        };

        // Update Marker Popup
        function updateMarkerPopup(client, marker) {
            const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${client.lat},${client.lng}`;

            const popupContent = `
                <div class="popup-content">
                    <h3>${client.name}</h3>
                    <p><strong>Endereço:</strong><br>${client.address}</p>
                    <div class="popup-buttons">
                        <button class="popup-navigate-btn" onclick="startNavigation(${client.id})">
                            🧭 Navegar pelo Mapa
                        </button>
                        <a href="${googleMapsUrl}" target="_blank" class="popup-route-btn">
                            🗺️ Abrir no Google Maps
                        </a>
                        <div class="popup-actions">
                            <button class="popup-edit-btn" onclick="openEditModal(${client.id})">
                                ✏️ Editar
                            </button>
                            <button class="popup-delete-btn" onclick="deleteClient(${client.id})">
                                🗑️ Excluir
                            </button>
                        </div>
                    </div>
                </div>
            `;

            marker.bindPopup(popupContent);
        }

        // Edit Client
        window.openEditModal = function(clientId) {
            const client = state.clients.find(c => c.id === clientId);
            if (!client) return;

            state.editingClientId = clientId;

            // Populate form
            document.getElementById('editClientName').value = client.name;
            document.getElementById('editClientAddress').value = client.address;
            document.getElementById('editClientPhone').value = client.phone || '';
            document.getElementById('editClientBR').value = client.br || '';

            // Show modal
            document.getElementById('editClientModal').classList.add('active');
            document.getElementById('editClientName').focus();
        };

        // Update Client
        async function updateClient(clientId, newName, newAddress, newBR, newPhone) {
            const client = state.clients.find(c => c.id === clientId);
            if (!client) return;

            // Verificar se o usuário está logado
            if (!state.currentUser || !state.currentUser.id) {
                showToast('Erro: Usuário não autenticado', 'error');
                return;
            }

            if (state.useSupabase) {
                try {
                    const { error } = await supabase
                        .from('clients')
                        .update({
                            name: newName,
                            address: newAddress,
                            br: newBR,
                            phone: newPhone
                        })
                        .eq('id', clientId)
                        .eq('user_id', state.currentUser.id);

                    if (error) throw error;

                    console.log(`✅ Cliente atualizado no Supabase (user_id: ${state.currentUser.id})`);
                } catch (error) {
                    console.error('Erro ao atualizar cliente:', error);

                    // Mensagens de erro específicas
                    let errorMessage = 'Erro ao atualizar cliente no banco de dados';

                    if (error.message && error.message.includes('column "phone"')) {
                        errorMessage = 'Erro: A coluna "phone" não existe no banco de dados. Execute este SQL no Supabase:\nALTER TABLE clients ADD COLUMN phone TEXT;';
                    } else if (error.code === '42703') {
                        errorMessage = 'Erro: Coluna não encontrada no banco de dados. Verifique a estrutura da tabela "clients" no Supabase.';
                    } else if (error.message) {
                        errorMessage = `Erro ao atualizar: ${error.message}`;
                    }

                    showToast(errorMessage, 'error');
                    console.error('💡 Detalhes do erro:', {
                        code: error.code,
                        message: error.message,
                        details: error.details,
                        hint: error.hint
                    });
                    return;
                }
            }

            // Update client data
            client.name = newName;
            client.address = newAddress;
            client.br = newBR;
            client.phone = newPhone;

            // Update marker
            const markerObj = state.clientMarkers.find(m => m.id === clientId);
            if (markerObj) {
                markerObj.marker.options.title = newName;
                updateMarkerPopup(client, markerObj.marker);
            }

            // Update list
            updateClientsList();
        }

        // Delete Client
        window.deleteClient = async function(clientId) {
            // Verificar se o usuário está logado
            if (!state.currentUser || !state.currentUser.id) {
                showToast('Erro: Usuário não autenticado', 'error');
                return;
            }

            if (state.useSupabase) {
                try {
                    const { error } = await supabase
                        .from('clients')
                        .delete()
                        .eq('id', clientId)
                        .eq('user_id', state.currentUser.id);

                    if (error) throw error;

                    console.log(`✅ Cliente excluído do Supabase (user_id: ${state.currentUser.id})`);
                } catch (error) {
                    console.error('Erro ao excluir cliente:', error);
                    showToast('Erro ao excluir cliente do banco de dados', 'error');
                    return;
                }
            }

            // Remove from array
            state.clients = state.clients.filter(c => c.id !== clientId);

            // Remove marker
            const markerObj = state.clientMarkers.find(m => m.id === clientId);
            if (markerObj) {
                state.map.removeLayer(markerObj.marker);
                state.clientMarkers = state.clientMarkers.filter(m => m.id !== clientId);
            }

            updateClientsList();
            showToast('Cliente excluído com sucesso!', 'success');
        };

        // Highlight search term in text
        function highlightText(text, query) {
            if (!query) return text;

            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<span class="highlight-text">$1</span>');
        }

        // Update Clients List
        function updateClientsList() {
            const listContainer = document.getElementById('clientsList');
            const countElement = document.getElementById('clientCount');
            const searchResultsInfo = document.getElementById('searchResultsInfo');

            countElement.textContent = `${state.clients.length} cliente${state.clients.length !== 1 ? 's' : ''} cadastrado${state.clients.length !== 1 ? 's' : ''}`;

            if (state.clients.length === 0) {
                listContainer.innerHTML = `
                    <div class="empty-state">
                        <svg fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd"/>
                        </svg>
                        <p>Nenhum cliente cadastrado ainda</p>
                        <p style="font-size: 12px; margin-top: 8px;">Use o botão + para adicionar</p>
                    </div>
                `;
                searchResultsInfo.textContent = '';
                return;
            }

            // Filter clients based on search query
            const query = state.searchQuery.toLowerCase().trim();
            const filteredClients = state.clients.filter(client => {
                if (!query) return true;

                const nameMatch = client.name.toLowerCase().includes(query);
                const addressMatch = client.address.toLowerCase().includes(query);

                return nameMatch || addressMatch;
            });

            // Update search results info
            if (query) {
                if (filteredClients.length === 0) {
                    searchResultsInfo.textContent = 'Nenhum resultado encontrado';
                } else if (filteredClients.length === 1) {
                    searchResultsInfo.textContent = '1 cliente encontrado';
                } else {
                    searchResultsInfo.textContent = `${filteredClients.length} clientes encontrados`;
                }
            } else {
                searchResultsInfo.textContent = '';
            }

            if (filteredClients.length === 0 && query) {
                listContainer.innerHTML = `
                    <div class="empty-state">
                        <svg fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"/>
                        </svg>
                        <p>Nenhum cliente encontrado</p>
                        <p style="font-size: 12px; margin-top: 8px;">Tente outro termo de busca</p>
                    </div>
                `;
                return;
            }

            listContainer.innerHTML = filteredClients.map(client => {
                const highlightedName = highlightText(client.name, query);
                const highlightedAddress = highlightText(client.address, query);
                const isHighlight = query ? 'highlight' : '';

                // Extrair apenas números do telefone para links
                const phoneNumbers = client.phone ? client.phone.replace(/\D/g, '') : '';
                const whatsappLink = phoneNumbers ? `https://wa.me/55${phoneNumbers}` : '';
                const telLink = phoneNumbers ? `tel:+55${phoneNumbers}` : '';

                return `
                    <div class="client-item ${isHighlight}">
                        <div onclick="focusClient(${client.id})" style="flex: 1; cursor: pointer;">
                            <div class="client-name">📍 ${highlightedName}</div>
                            <div class="client-address">${highlightedAddress}</div>
                            ${client.phone ? `<div class="client-phone" style="font-size: 12px; color: #666; margin-top: 4px;">📞 ${client.phone}</div>` : ''}
                        </div>
                        ${phoneNumbers ? `
                            <div style="display: flex; gap: 8px; align-items: center; margin-left: 8px;">
                                <a href="${whatsappLink}" target="_blank" onclick="event.stopPropagation()"
                                   style="display: flex; align-items: center; justify-content: center; width: 36px; height: 36px; background: #25D366; border-radius: 50%; text-decoration: none; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                                   title="Enviar WhatsApp">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
                                        <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z"/>
                                    </svg>
                                </a>
                                <a href="${telLink}" onclick="event.stopPropagation()"
                                   style="display: flex; align-items: center; justify-content: center; width: 36px; height: 36px; background: #3b82f6; border-radius: 50%; text-decoration: none; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                                   title="Ligar">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="white">
                                        <path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56a.977.977 0 00-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-1.18v-3.45c0-.54-.45-.99-.99-.99z"/>
                                    </svg>
                                </a>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // Focus on Client
        window.focusClient = function(clientId) {
            const client = state.clients.find(c => c.id === clientId);
            if (client) {
                state.map.setView([client.lat, client.lng], 18);

                const markerObj = state.clientMarkers.find(m => m.id === clientId);
                if (markerObj) {
                    markerObj.marker.openPopup();
                }

                // Close sidebar on mobile
                if (window.innerWidth <= 768) {
                    document.getElementById('sidebar').classList.remove('open');
                }
            }
        };

        // QR Code Scanner Controls - OTIMIZADO
        const scanBtn = document.getElementById('scanBtn');
        const cameraPreview = document.getElementById('cameraPreview');
        const cameraVideo = document.getElementById('cameraVideo');
        const cameraCanvas = document.getElementById('cameraCanvas');
        const processingOverlay = document.getElementById('processingOverlay');
        let cameraStream = null;
        let qrScanActive = false;
        let canvasContext = null;

        // Open/Close QR Scanner
        scanBtn.addEventListener('click', async () => {
            if (cameraStream) {
                // Close camera
                qrScanActive = false;
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
                cameraPreview.classList.remove('active');
                scanBtn.textContent = '📷 Escanear QR Code';
                scanBtn.style.background = '';
            } else {
                // Open camera with optimized settings
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    cameraVideo.srcObject = cameraStream;
                    cameraPreview.classList.add('active');
                    scanBtn.textContent = '✖ Fechar Câmera';
                    scanBtn.style.background = '#ef4444';

                    // Initialize canvas context once
                    if (!canvasContext) {
                        canvasContext = cameraCanvas.getContext('2d', { willReadFrequently: true });
                    }

                    // Start optimized QR scanning
                    qrScanActive = true;
                    requestAnimationFrame(scanQRCode);
                } catch (error) {
                    console.error('Erro ao acessar câmera:', error);
                    showToast('Não foi possível acessar a câmera. Verifique as permissões.', 'error');
                }
            }
        });

        // ULTRA-FAST QR Code scanning with multi-scale detection
        function scanQRCode() {
            if (!qrScanActive || cameraVideo.readyState !== cameraVideo.HAVE_ENOUGH_DATA) {
                if (qrScanActive) requestAnimationFrame(scanQRCode);
                return;
            }

            const videoWidth = cameraVideo.videoWidth;
            const videoHeight = cameraVideo.videoHeight;

            // Try multiple scales for better detection (especially with low-quality QR codes)
            const scales = [0.6, 0.4]; // Try 60% then 40% if not found

            for (const scale of scales) {
                const width = Math.floor(videoWidth * scale);
                const height = Math.floor(videoHeight * scale);

                // Resize canvas only if needed
                if (cameraCanvas.width !== width || cameraCanvas.height !== height) {
                    cameraCanvas.width = width;
                    cameraCanvas.height = height;
                }

                // Apply image enhancements for better detection
                canvasContext.save();
                canvasContext.filter = 'contrast(1.2) brightness(1.1)';
                canvasContext.drawImage(cameraVideo, 0, 0, width, height);
                canvasContext.restore();

                // Get image data
                const imageData = canvasContext.getImageData(0, 0, width, height);

                // Scan with aggressive inversion attempts for damaged QR codes
                const code = jsQR(imageData.data, width, height, {
                    inversionAttempts: "attemptBoth" // Try both normal and inverted for damaged codes
                });

                if (code) {
                    console.log('✅ QR Code detectado:', code.data);

                    // Strong visual feedback
                    cameraVideo.style.filter = 'brightness(1.5)';
                    setTimeout(() => { cameraVideo.style.filter = ''; }, 150);

                    // Vibrate
                    if ('vibrate' in navigator) {
                        navigator.vibrate([50, 30, 50]); // Double vibration pattern
                    }

                    // Fill BR field
                    document.getElementById('clientBR').value = code.data;

                    // Buscar endereço na planilha automaticamente
                    const brCode = code.data.trim();
                    if (state.brDatabase[brCode]) {
                        document.getElementById('clientAddress').value = state.brDatabase[brCode];
                        showToast('✓ QR Code lido! Endereço preenchido automaticamente.', 'success');
                    } else {
                        showToast('✓ QR Code lido! Endereço não encontrado na planilha.', 'warning');
                    }

                    // Close camera
                    qrScanActive = false;
                    if (cameraStream) {
                        cameraStream.getTracks().forEach(track => track.stop());
                        cameraStream = null;
                    }
                    cameraPreview.classList.remove('active');
                    scanBtn.textContent = '📷 Escanear QR Code';
                    scanBtn.style.background = '';
                    return;
                }
            }

            // Continue scanning immediately for maximum speed
            requestAnimationFrame(scanQRCode);
        }

        // Função para formatar telefone
        function formatPhone(value) {
            // Remove tudo que não é número
            const numbers = value.replace(/\D/g, '');

            // Limita a 11 dígitos (DDD + 9 dígitos)
            const limited = numbers.substring(0, 11);

            // Formata: (99) 99942-1942
            if (limited.length <= 2) {
                return limited;
            } else if (limited.length <= 7) {
                return `(${limited.substring(0, 2)}) ${limited.substring(2)}`;
            } else {
                return `(${limited.substring(0, 2)}) ${limited.substring(2, 7)}-${limited.substring(7)}`;
            }
        }

        // ========== FUNÇÕES DE VALIDAÇÃO E MENSAGENS DE ERRO ==========

        // Mostrar erro geral
        function showFormError(formType, message) {
            const errorEl = document.getElementById(`${formType}Error`);
            if (errorEl) {
                errorEl.innerHTML = `<strong>❌ Erro</strong> ${message}`;
                errorEl.classList.add('show');

                // Auto-hide após 5 segundos
                setTimeout(() => {
                    errorEl.classList.remove('show');
                }, 5000);
            }
        }

        // Mostrar erro de campo específico
        function showFieldError(fieldId, message) {
            const errorEl = document.getElementById(`${fieldId}Error`);
            const inputEl = document.getElementById(fieldId);

            if (errorEl) {
                errorEl.textContent = message;
                errorEl.classList.add('show');
            }

            if (inputEl) {
                inputEl.classList.add('error');
                inputEl.classList.remove('success');
            }
        }

        // Limpar erro de campo específico
        function clearFieldError(fieldId) {
            const errorEl = document.getElementById(`${fieldId}Error`);
            const inputEl = document.getElementById(fieldId);

            if (errorEl) {
                errorEl.classList.remove('show');
            }

            if (inputEl) {
                inputEl.classList.remove('error');
            }
        }

        // Marcar campo como válido
        function markFieldSuccess(fieldId) {
            const inputEl = document.getElementById(fieldId);

            if (inputEl) {
                inputEl.classList.remove('error');
                inputEl.classList.add('success');
            }
        }

        // Limpar todos os erros de um formulário
        function clearFormErrors(formType) {
            const errorEl = document.getElementById(`${formType}Error`);
            if (errorEl) {
                errorEl.classList.remove('show');
            }

            // Limpar todos os inputs do formulário
            const form = document.getElementById(`${formType}Form`);
            if (form) {
                const inputs = form.querySelectorAll('input');
                inputs.forEach(input => {
                    input.classList.remove('error', 'success');
                });

                const fieldErrors = form.querySelectorAll('.field-error');
                fieldErrors.forEach(error => {
                    error.classList.remove('show');
                });
            }
        }

        // Validar campo em tempo real
        function validateField(fieldId, validationFn) {
            const inputEl = document.getElementById(fieldId);
            if (!inputEl) return;

            inputEl.addEventListener('input', () => {
                clearFieldError(fieldId);
                const error = validationFn(inputEl.value);

                if (error) {
                    showFieldError(fieldId, error);
                } else if (inputEl.value.length > 0) {
                    markFieldSuccess(fieldId);
                }
            });

            inputEl.addEventListener('blur', () => {
                const error = validationFn(inputEl.value);
                if (error && inputEl.value.length > 0) {
                    showFieldError(fieldId, error);
                }
            });
        }

        // Validações específicas
        function validateUsername(value) {
            if (!value || value.trim().length === 0) {
                return 'Usuário é obrigatório';
            }
            if (value.length < 3) {
                return 'Usuário deve ter pelo menos 3 caracteres';
            }
            if (!/^[a-zA-Z0-9_-]+$/.test(value)) {
                return 'Usuário pode conter apenas letras, números, _ e -';
            }
            return null;
        }

        function validatePassword(value) {
            if (!value || value.length === 0) {
                return 'Senha é obrigatória';
            }
            if (value.length < 4) {
                return 'Senha deve ter pelo menos 4 caracteres';
            }
            return null;
        }

        function validateName(value) {
            if (!value || value.trim().length === 0) {
                return 'Nome é obrigatório';
            }
            if (value.trim().length < 3) {
                return 'Nome deve ter pelo menos 3 caracteres';
            }
            return null;
        }

        function validatePasswordConfirm(password, confirm) {
            if (!confirm || confirm.length === 0) {
                return 'Confirmação de senha é obrigatória';
            }
            if (password !== confirm) {
                return 'As senhas não coincidem';
            }
            return null;
        }

        // ========== EVENT LISTENERS - AUTENTICAÇÃO ==========

        // Login Form
        const loginForm = document.getElementById('loginForm');
        const loginBtn = document.getElementById('loginBtn');

        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            // Limpar erros anteriores
            clearFormErrors('login');

            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;

            // Validar campos
            let hasError = false;

            const usernameError = validateUsername(username);
            if (usernameError) {
                showFieldError('loginUsername', usernameError);
                hasError = true;
            }

            const passwordError = validatePassword(password);
            if (passwordError) {
                showFieldError('loginPassword', passwordError);
                hasError = true;
            }

            if (hasError) {
                showFormError('login', 'Por favor, corrija os erros antes de continuar');
                return;
            }

            loginBtn.disabled = true;
            loginBtn.textContent = 'Entrando...';

            const success = await login(username, password);

            // Sempre resetar o botão
            loginBtn.disabled = false;
            loginBtn.textContent = 'Entrar';

            if (success) {
                loginForm.reset();
                clearFormErrors('login');
            } else {
                // Mostrar erro de login
                showFormError('login', 'Usuário ou senha incorretos. Verifique seus dados e tente novamente.');
            }
        });

        // Register Form
        const registerForm = document.getElementById('registerForm');
        const registerBtn = document.getElementById('registerBtn');
        const showRegisterBtn = document.getElementById('showRegisterBtn');
        const showLoginBtn = document.getElementById('showLoginBtn');
        const loginContainer = document.getElementById('loginContainer');
        const registerContainer = document.getElementById('registerContainer');

        // Mostrar tela de cadastro
        showRegisterBtn.addEventListener('click', () => {
            loginContainer.classList.add('hidden');
            registerContainer.classList.remove('hidden');
        });

        // Voltar para tela de login
        showLoginBtn.addEventListener('click', () => {
            registerContainer.classList.add('hidden');
            loginContainer.classList.remove('hidden');
            registerForm.reset();
            clearFormErrors('register');
        });

        // ========== VALIDAÇÕES EM TEMPO REAL ==========

        // Login - validações em tempo real
        validateField('loginUsername', validateUsername);
        validateField('loginPassword', validatePassword);

        // Registro - validações em tempo real
        validateField('registerName', validateName);
        validateField('registerUsername', validateUsername);
        validateField('registerPassword', validatePassword);

        // Validação especial para confirmação de senha (precisa comparar com a senha)
        const registerPasswordInput = document.getElementById('registerPassword');
        const registerPasswordConfirmInput = document.getElementById('registerPasswordConfirm');

        registerPasswordConfirmInput.addEventListener('input', () => {
            clearFieldError('registerPasswordConfirm');
            const password = registerPasswordInput.value;
            const confirm = registerPasswordConfirmInput.value;

            if (confirm.length > 0) {
                const error = validatePasswordConfirm(password, confirm);
                if (error) {
                    showFieldError('registerPasswordConfirm', error);
                } else {
                    markFieldSuccess('registerPasswordConfirm');
                }
            }
        });

        registerPasswordConfirmInput.addEventListener('blur', () => {
            const password = registerPasswordInput.value;
            const confirm = registerPasswordConfirmInput.value;

            if (confirm.length > 0) {
                const error = validatePasswordConfirm(password, confirm);
                if (error) {
                    showFieldError('registerPasswordConfirm', error);
                }
            }
        });

        // Processar cadastro
        registerForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            // Limpar erros anteriores
            clearFormErrors('register');

            const name = document.getElementById('registerName').value.trim();
            const username = document.getElementById('registerUsername').value.trim();
            const password = document.getElementById('registerPassword').value;
            const passwordConfirm = document.getElementById('registerPasswordConfirm').value;

            // Validar todos os campos
            let hasError = false;

            const nameError = validateName(name);
            if (nameError) {
                showFieldError('registerName', nameError);
                hasError = true;
            }

            const usernameError = validateUsername(username);
            if (usernameError) {
                showFieldError('registerUsername', usernameError);
                hasError = true;
            }

            const passwordError = validatePassword(password);
            if (passwordError) {
                showFieldError('registerPassword', passwordError);
                hasError = true;
            }

            const passwordConfirmError = validatePasswordConfirm(password, passwordConfirm);
            if (passwordConfirmError) {
                showFieldError('registerPasswordConfirm', passwordConfirmError);
                hasError = true;
            }

            if (hasError) {
                showFormError('register', 'Por favor, corrija os erros antes de continuar');
                return;
            }

            registerBtn.disabled = true;
            registerBtn.textContent = 'Criando conta...';

            const success = await registerUser(name, username, password);

            if (success) {
                registerForm.reset();
                clearFormErrors('register');
                registerContainer.classList.add('hidden');
                loginContainer.classList.remove('hidden');
                // Preencher username no login
                document.getElementById('loginUsername').value = username;
                document.getElementById('loginPassword').focus();
                showToast('✅ Conta criada com sucesso! Faça login para continuar.', 'success');
            } else {
                showFormError('register', 'Erro ao criar conta. O usuário pode já estar em uso. Tente outro nome de usuário.');
            }

            registerBtn.disabled = false;
            registerBtn.textContent = 'Criar Conta';
        });

        // Logout Button
        document.getElementById('logoutBtn').addEventListener('click', () => {
            logout();
        });

        // Open Admin Panel
        document.getElementById('openAdminBtn').addEventListener('click', () => {
            document.getElementById('adminPanel').classList.add('active');
            loadUsers();
        });

        // Close Admin Panel
        document.getElementById('closeAdminBtn').addEventListener('click', () => {
            document.getElementById('adminPanel').classList.remove('active');
        });

        // Open Settings Panel
        document.getElementById('openSettingsBtn').addEventListener('click', async () => {
            const panel = document.getElementById('settingsPanel');
            panel.classList.add('active');

            // Recarregar configurações do Supabase (caso outro admin tenha alterado)
            await loadGlobalSettings();

            // Carregar API Key salva no state (se houver)
            if (state.googleMapsApiKey) {
                document.getElementById('googleMapsApiKey').value = state.googleMapsApiKey;
            } else {
                document.getElementById('googleMapsApiKey').value = '';
            }
        });

        // Close Settings Panel
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            document.getElementById('settingsPanel').classList.remove('active');
        });

        // Test API Key
        document.getElementById('testApiKeyBtn').addEventListener('click', async () => {
            const apiKey = document.getElementById('googleMapsApiKey').value.trim();
            const statusEl = document.getElementById('apiKeyStatus');
            const testBtn = document.getElementById('testApiKeyBtn');

            if (!apiKey) {
                statusEl.textContent = '⚠️ Por favor, insira uma API Key primeiro.';
                statusEl.style.background = '#fee2e2';
                statusEl.style.color = '#991b1b';
                statusEl.style.display = 'block';
                setTimeout(() => statusEl.style.display = 'none', 3000);
                return;
            }

            // Desabilitar botão enquanto testa
            testBtn.disabled = true;
            testBtn.textContent = '🧪 Testando...';

            statusEl.textContent = '⏳ Testando Google Maps API...';
            statusEl.style.background = '#dbeafe';
            statusEl.style.color = '#1e40af';
            statusEl.style.display = 'block';

            try {
                // Salvar temporariamente a API Key no state para testar
                const previousKey = state.googleMapsApiKey;
                state.googleMapsApiKey = apiKey;

                // Fazer uma requisição de teste real (São Paulo → Campinas - ~100km)
                const testResult = await fetchFromGoogleMaps(
                    -23.5505, // São Paulo (lat)
                    -46.6333, // São Paulo (lng)
                    -22.9099, // Campinas (lat)
                    -47.0626  // Campinas (lng)
                );

                // Restaurar key anterior
                state.googleMapsApiKey = previousKey;

                if (testResult && testResult.coordinates && testResult.coordinates.length > 1) {
                    // Sucesso!
                    const distanceKm = (testResult.distance / 1000).toFixed(1);
                    const durationMin = Math.round(testResult.duration / 60);

                    statusEl.innerHTML = `✅ <strong>API Key VÁLIDA!</strong><br>
                        <small>Teste: São Paulo → Campinas (${distanceKm}km, ~${durationMin}min)</small><br>
                        <small>Google Maps funcionando perfeitamente! 🎉</small>`;
                    statusEl.style.background = '#d1fae5';
                    statusEl.style.color = '#065f46';
                    showToast('✅ API Key válida e funcionando!', 'success');
                } else {
                    // Falhou - pode ser key inválida, API não ativada, ou problema de permissão
                    statusEl.innerHTML = `❌ <strong>Erro ao usar API Key</strong><br>
                        <small>Possíveis causas:</small><br>
                        <small>• API Key inválida ou expirada</small><br>
                        <small>• Directions API não ativada no projeto</small><br>
                        <small>• Restrições da API Key bloqueando uso</small><br>
                        <small>• Verifique o Console do Google Cloud</small>`;
                    statusEl.style.background = '#fee2e2';
                    statusEl.style.color = '#991b1b';
                    showToast('❌ API Key não funcionou', 'error');
                }

            } catch (error) {
                statusEl.innerHTML = `❌ <strong>Erro ao testar:</strong> ${error.message}<br>
                    <small>Verifique o console do navegador (F12) para mais detalhes</small>`;
                statusEl.style.background = '#fee2e2';
                statusEl.style.color = '#991b1b';
                console.error('Erro ao testar API Key:', error);
                showToast('❌ Erro ao testar API Key', 'error');
            }

            // Restaurar botão
            testBtn.disabled = false;
            testBtn.textContent = '🧪 Testar';

            // Manter mensagem visível por mais tempo
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 15000); // 15 segundos
        });

        // Save API Key (salva no Supabase para todos os usuários)
        document.getElementById('saveApiKeyBtn').addEventListener('click', async () => {
            const apiKey = document.getElementById('googleMapsApiKey').value.trim();
            const statusEl = document.getElementById('apiKeyStatus');
            const saveBtn = document.getElementById('saveApiKeyBtn');

            if (!apiKey) {
                statusEl.textContent = '⚠️ Por favor, insira uma API Key válida.';
                statusEl.style.background = '#fee2e2';
                statusEl.style.color = '#991b1b';
                statusEl.style.display = 'block';
                setTimeout(() => statusEl.style.display = 'none', 5000);
                return;
            }

            // Desabilitar botão enquanto salva
            saveBtn.disabled = true;
            saveBtn.textContent = '💾 Salvando...';

            const success = await saveGlobalSettings(apiKey);

            if (success) {
                statusEl.textContent = '✅ API Key salva! Todas as contas agora usarão Google Maps.';
                statusEl.style.background = '#d1fae5';
                statusEl.style.color = '#065f46';
                statusEl.style.display = 'block';

                showToast('API Key configurada para todas as contas!', 'success');
            } else {
                statusEl.textContent = '❌ Erro ao salvar API Key. Tente novamente.';
                statusEl.style.background = '#fee2e2';
                statusEl.style.color = '#991b1b';
                statusEl.style.display = 'block';
            }

            // Restaurar botão
            saveBtn.disabled = false;
            saveBtn.textContent = '💾 Salvar';

            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        });

        // Clear API Key (remove do Supabase)
        document.getElementById('clearApiKeyBtn').addEventListener('click', async () => {
            const statusEl = document.getElementById('apiKeyStatus');
            const clearBtn = document.getElementById('clearApiKeyBtn');

            // Desabilitar botão enquanto remove
            clearBtn.disabled = true;
            clearBtn.textContent = '🗑️ Removendo...';

            const success = await saveGlobalSettings(null); // Salvar null = remover

            if (success) {
                document.getElementById('googleMapsApiKey').value = '';

                statusEl.textContent = '🗑️ API Key removida. Todas as contas usarão APIs gratuitas.';
                statusEl.style.background = '#dbeafe';
                statusEl.style.color = '#1e40af';
                statusEl.style.display = 'block';

                showToast('API Key removida. Usando APIs gratuitas.', 'success');
            } else {
                statusEl.textContent = '❌ Erro ao remover API Key.';
                statusEl.style.background = '#fee2e2';
                statusEl.style.color = '#991b1b';
                statusEl.style.display = 'block';
            }

            // Restaurar botão
            clearBtn.disabled = false;
            clearBtn.textContent = '🗑️ Limpar';

            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        });

        // Add User Modal
        const addUserModal = document.getElementById('addUserModal');
        const addUserBtn = document.getElementById('addUserBtn');
        const cancelUserBtn = document.getElementById('cancelUserBtn');
        const userForm = document.getElementById('userForm');

        addUserBtn.addEventListener('click', () => {
            addUserModal.classList.add('active');
            document.getElementById('newUsername').focus();
        });

        cancelUserBtn.addEventListener('click', () => {
            addUserModal.classList.remove('active');
            userForm.reset();
        });

        addUserModal.addEventListener('click', (e) => {
            if (e.target === addUserModal) {
                addUserModal.classList.remove('active');
                userForm.reset();
            }
        });

        userForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const name = document.getElementById('newUserName').value.trim();
            const username = document.getElementById('newUsername').value.trim();
            const password = document.getElementById('newUserPassword').value;
            const role = document.getElementById('newUserRole').value;

            if (!name || !username || !password) {
                showToast('Por favor, preencha todos os campos', 'warning');
                return;
            }

            const success = await createUser(name, username, password, role);

            if (success) {
                addUserModal.classList.remove('active');
                userForm.reset();
            }
        });

        // Edit User Modal
        const editUserModal = document.getElementById('editUserModal');
        const cancelEditUserBtn = document.getElementById('cancelEditUserBtn');
        const editUserForm = document.getElementById('editUserForm');

        cancelEditUserBtn.addEventListener('click', () => {
            editUserModal.classList.remove('active');
            editUserForm.reset();
            state.editingUserId = null;
        });

        editUserModal.addEventListener('click', (e) => {
            if (e.target === editUserModal) {
                editUserModal.classList.remove('active');
                editUserForm.reset();
                state.editingUserId = null;
            }
        });

        editUserForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const name = document.getElementById('editUserName').value.trim();
            const username = document.getElementById('editUsername').value.trim();
            const password = document.getElementById('editUserPassword').value;
            const role = document.getElementById('editUserRole').value;

            if (!name || !username) {
                showToast('Por favor, preencha o nome completo e nome de usuário', 'warning');
                return;
            }

            if (state.editingUserId) {
                const success = await updateUser(state.editingUserId, name, username, password, role);

                if (success) {
                    editUserModal.classList.remove('active');
                    editUserForm.reset();
                    state.editingUserId = null;
                }
            }
        });

        // Add Client Modal Controls
        const addModal = document.getElementById('addClientModal');
        const addClientBtn = document.getElementById('addClientBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const clientForm = document.getElementById('clientForm');
        const clientPhoneInput = document.getElementById('clientPhone');
        const editClientPhoneInput = document.getElementById('editClientPhone');

        // Formatação automática do telefone
        clientPhoneInput.addEventListener('input', (e) => {
            e.target.value = formatPhone(e.target.value);
        });

        editClientPhoneInput.addEventListener('input', (e) => {
            e.target.value = formatPhone(e.target.value);
        });

        addClientBtn.addEventListener('click', () => {
            if (!state.currentLocation) {
                showToast('Aguardando localização...', 'warning');
                return;
            }

            addModal.classList.add('active');
            document.getElementById('clientName').focus();
        });

        cancelBtn.addEventListener('click', () => {
            // Fechar câmera se estiver aberta
            qrScanActive = false;
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            cameraPreview.classList.remove('active');
            scanBtn.textContent = '📷 Escanear QR Code';
            scanBtn.style.background = '';

            addModal.classList.remove('active');
            clientForm.reset();
        });

        addModal.addEventListener('click', (e) => {
            if (e.target === addModal) {
                // Fechar câmera se estiver aberta
                qrScanActive = false;
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                    cameraStream = null;
                }
                cameraPreview.classList.remove('active');
                scanBtn.textContent = '📷 Escanear QR Code';
                scanBtn.style.background = '';

                addModal.classList.remove('active');
                clientForm.reset();
            }
        });

        clientForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const name = document.getElementById('clientName').value.trim();
            const address = document.getElementById('clientAddress').value.trim();
            const phone = document.getElementById('clientPhone').value.trim();
            const br = document.getElementById('clientBR').value.trim();

            if (!name || !address) {
                showToast('Por favor, preencha todos os campos.', 'warning');
                return;
            }

            const client = await addClient(name, address, state.currentLocation.lat, state.currentLocation.lng, br, phone);

            if (!client) return; // Error already shown

            addModal.classList.remove('active');
            clientForm.reset();

            // Show success feedback
            showToast(`Cliente "${name}" adicionado com sucesso!`, 'success');
            const originalText = addClientBtn.textContent;
            addClientBtn.textContent = '✓';
            addClientBtn.style.background = '#10b981';
            setTimeout(() => {
                addClientBtn.textContent = originalText;
                addClientBtn.style.background = '';
            }, 1500);
        });

        // Edit Client Modal Controls
        const editModal = document.getElementById('editClientModal');
        const editCancelBtn = document.getElementById('editCancelBtn');
        const editClientForm = document.getElementById('editClientForm');

        editCancelBtn.addEventListener('click', () => {
            editModal.classList.remove('active');
            editClientForm.reset();
            state.editingClientId = null;
        });

        editModal.addEventListener('click', (e) => {
            if (e.target === editModal) {
                editModal.classList.remove('active');
                editClientForm.reset();
                state.editingClientId = null;
            }
        });

        editClientForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const name = document.getElementById('editClientName').value.trim();
            const address = document.getElementById('editClientAddress').value.trim();
            const phone = document.getElementById('editClientPhone').value.trim();
            const br = document.getElementById('editClientBR').value.trim();

            if (!name || !address) {
                showToast('Por favor, preencha todos os campos.', 'warning');
                return;
            }

            if (state.editingClientId) {
                await updateClient(state.editingClientId, name, address, br, phone);
                showToast(`Cliente "${name}" atualizado com sucesso!`, 'success');
            }

            editModal.classList.remove('active');
            editClientForm.reset();
            state.editingClientId = null;
        });

        // Search Functionality
        const searchInput = document.getElementById('searchInput');
        const clearSearchBtn = document.getElementById('clearSearch');

        searchInput.addEventListener('input', (e) => {
            state.searchQuery = e.target.value;
            updateClientsList();

            // Show/hide clear button
            if (state.searchQuery) {
                clearSearchBtn.classList.add('visible');
            } else {
                clearSearchBtn.classList.remove('visible');
            }
        });

        clearSearchBtn.addEventListener('click', () => {
            searchInput.value = '';
            state.searchQuery = '';
            clearSearchBtn.classList.remove('visible');
            updateClientsList();
            searchInput.focus();
        });

        // Mobile Menu Toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');

        // Toggle sidebar
        menuToggle.addEventListener('click', () => {
            const isOpen = sidebar.classList.toggle('open');
            sidebarOverlay.classList.toggle('active', isOpen);
            const userHeaderInfo = document.getElementById('userHeaderInfo');

            // Previne scroll do body quando sidebar está aberta
            if (isOpen) {
                document.body.style.overflow = 'hidden';
                // Oculta o banner de Admin/Sair
                if (userHeaderInfo) {
                    userHeaderInfo.style.opacity = '0';
                    userHeaderInfo.style.pointerEvents = 'none';
                }
            } else {
                document.body.style.overflow = '';
                // Mostra o banner de Admin/Sair
                if (userHeaderInfo) {
                    userHeaderInfo.style.opacity = '1';
                    userHeaderInfo.style.pointerEvents = 'auto';
                }
            }
        });

        // Close sidebar when clicking on overlay
        sidebarOverlay.addEventListener('click', () => {
            sidebar.classList.remove('open');
            sidebarOverlay.classList.remove('active');
            document.body.style.overflow = '';
            const userHeaderInfo = document.getElementById('userHeaderInfo');
            // Mostra o banner de Admin/Sair
            if (userHeaderInfo) {
                userHeaderInfo.style.opacity = '1';
                userHeaderInfo.style.pointerEvents = 'auto';
            }
        });

        // Close sidebar when clicking on map (mobile)
        document.getElementById('map').addEventListener('click', () => {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('active');
                document.body.style.overflow = '';
                const userHeaderInfo = document.getElementById('userHeaderInfo');
                // Mostra o banner de Admin/Sair
                if (userHeaderInfo) {
                    userHeaderInfo.style.opacity = '1';
                    userHeaderInfo.style.pointerEvents = 'auto';
                }
            }
        });

        // State for route optimization
        state.routeData = [];  // Armazena dados da planilha para roteirização
        state.uploadSessionId = null; // ID único da sessão de upload atual
        state.optimizedRoute = null;  // Rota otimizada pela IA
        state.routePolylines = [];  // Polylines da rota otimizada

        // Limpar e organizar endereço - remove referências após o número
        function cleanAddress(address) {
            if (!address) return '';

            // Remover espaços extras
            let cleaned = address.trim();

            // Padrão: capturar até o número e ignorar o resto
            // Exemplos que vai capturar:
            // "Rua X, 123" -> "Rua X, 123"
            // "Rua X, 123, Próximo a..." -> "Rua X, 123"
            // "Alameda Y, 456, Casa branca" -> "Alameda Y, 456"

            // Regex: captura tudo até encontrar número seguido de vírgula ou fim de string
            const match = cleaned.match(/^([^,]+,\s*\d+[A-Za-z]?)/);

            if (match) {
                cleaned = match[1];
                console.log(`🧹 Endereço limpo: "${address}" → "${cleaned}"`);
            } else {
                // Se não encontrou padrão "rua, número", retorna original
                console.log(`⚠️ Formato não padrão, usando original: "${address}"`);
            }

            return cleaned;
        }

        // Geocoding usando Nominatim (OpenStreetMap) - Funciona em qualquer ambiente web
        async function geocodeAddress(address, city = '', zipcode = '', bairro = '') {
            try {
                // LIMPAR endereço antes de fazer geocoding (remove referências)
                const cleanedAddress = cleanAddress(address);

                // Construir query completo com endereço limpo
                let query = cleanedAddress;
                if (bairro) query += `, ${bairro}`;
                if (city) query += `, ${city}`;
                if (zipcode) query += `, ${zipcode}`;
                query += ', Brasil';

                console.log(`🔍 Geocoding: ${query}`);

                // Usar Nominatim (OpenStreetMap) - API gratuita e funciona em qualquer lugar
                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1&countrycodes=br&addressdetails=1`;

                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'GPS-Navigation-App-Vercel'
                    }
                });

                if (!response.ok) {
                    console.warn(`❌ Geocoding falhou: HTTP ${response.status}`);
                    return null;
                }

                const results = await response.json();

                if (results && results.length > 0) {
                    const result = results[0];
                    console.log(`✅ Geocoded: ${result.display_name}`);
                    return {
                        latitude: parseFloat(result.lat),
                        longitude: parseFloat(result.lon),
                        displayName: result.display_name,
                        confidence: result.importance || 0.5
                    };
                }

                console.warn(`⚠️ Nenhum resultado encontrado para: ${query}`);
                return null;

            } catch (error) {
                console.error('❌ Erro no geocoding:', error);
                return null;
            }
        }

        // Calculate distance between two coordinates (Haversine formula) in km
        function calculateDistanceBetweenCoords(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Use AI to validate and correct address coordinates
        async function validateAddressWithAI(item) {
            return new Promise((resolve, reject) => {
                const handlerName = `ai-geocode-${Date.now()}`;

                // Register handler for AI response
                window.Poe.registerHandler(handlerName, (result) => {
                    if (result.status === 'complete' && result.responses && result.responses.length > 0) {
                        const response = result.responses[0];
                        try {
                            // Parse JSON response from AI
                            const jsonMatch = response.content.match(/\{[\s\S]*"latitude"[\s\S]*"longitude"[\s\S]*\}/);
                            if (jsonMatch) {
                                const coords = JSON.parse(jsonMatch[0]);
                                if (coords.latitude && coords.longitude) {
                                    resolve({
                                        latitude: parseFloat(coords.latitude),
                                        longitude: parseFloat(coords.longitude)
                                    });
                                    return;
                                }
                            }
                            resolve(null);
                        } catch (error) {
                            console.error('Erro ao parsear resposta da IA:', error);
                            resolve(null);
                        }
                    } else if (result.status === 'error') {
                        resolve(null);
                    }
                });

                // Send request to AI
                const prompt = `Preciso validar e corrigir as coordenadas de um endereço no Brasil.

Endereço: ${item.address}
Bairro: ${item.bairro || 'não informado'}
Cidade: ${item.city || 'não informada'}
CEP: ${item.zipcode || 'não informado'}
Coordenadas originais: ${item.originalLatitude}, ${item.originalLongitude}

Por favor, retorne APENAS um objeto JSON com as coordenadas corretas e precisas do endereço (no ponto exato da rua e número), no formato:
{"latitude": -23.550520, "longitude": -46.633308}

Se não conseguir encontrar o endereço exato, retorne {"latitude": null, "longitude": null}`;

                window.Poe.sendUserMessage(`@GPT-5.1 ${prompt}`, {
                    handler: handlerName,
                    stream: false,
                    openChat: false
                }).catch(error => {
                    console.error('Erro ao enviar mensagem para IA:', error);
                    resolve(null);
                });

                // Timeout de 30 segundos
                setTimeout(() => resolve(null), 30000);
            });
        }

        // Geocode all addresses usando Nominatim - Funciona em QUALQUER ambiente web
        async function geocodeAllAddresses(routeData, statusElement, sessionId) {
            let successCount = 0;
            let failedCount = 0;
            let usedFromSheet = 0;

            console.log(`🗺️ Iniciando geocoding ULTRA-RÁPIDO de ${routeData.length} endereços (user_id: ${state.currentUser?.id}, session: ${sessionId})...`);
            console.log(`⚡ Processamento paralelo máximo (15 requisições simultâneas)`);

            // Separar endereços que já têm coordenadas (não precisam geocoding)
            const needsGeocoding = [];
            const alreadyHasCoords = [];

            routeData.forEach(item => {
                if (item.latitude && item.longitude &&
                    !isNaN(parseFloat(item.latitude)) && !isNaN(parseFloat(item.longitude))) {
                    // Já tem coordenadas válidas na planilha
                    alreadyHasCoords.push(item);
                    item.addressCleaned = cleanAddress(item.address);
                    usedFromSheet++;
                } else {
                    needsGeocoding.push(item);
                }
            });

            console.log(`📊 ${alreadyHasCoords.length} endereços já têm coordenadas (pulando geocoding)`);
            console.log(`🔍 ${needsGeocoding.length} endereços precisam de geocoding`);

            // Se todos já têm coordenadas, finalizar imediatamente
            if (needsGeocoding.length === 0) {
                console.log(`✅ Todos os endereços já têm coordenadas válidas!`);
                statusElement.textContent = `✅ ${routeData.length} endereços prontos (usando planilha)`;
                showToast(`${usedFromSheet} endereços carregados da planilha`, 'success');
                return;
            }

            // Processar em lotes de 15 endereços simultaneamente (MÁXIMO DESEMPENHO)
            const BATCH_SIZE = 15;
            const DELAY_BETWEEN_BATCHES = 50; // Apenas 50ms entre lotes (ultra-rápido)

            for (let batchStart = 0; batchStart < needsGeocoding.length; batchStart += BATCH_SIZE) {
                // Verificar se esta sessão ainda é válida
                if (state.uploadSessionId !== sessionId) {
                    console.log(`⚠️ Sessão de upload cancelada ou substituída. Parando geocoding.`);
                    return;
                }

                const batchEnd = Math.min(batchStart + BATCH_SIZE, needsGeocoding.length);
                const batch = needsGeocoding.slice(batchStart, batchEnd);

                // Processar lote em paralelo (todas as 15 requisições ao mesmo tempo)
                const promises = batch.map(async (item, batchIndex) => {
                    const globalIndex = batchStart + batchIndex;

                    try {
                        // Fazer geocoding do endereço
                        const geocoded = await geocodeAddress(item.address, item.city, item.zipcode, item.bairro);

                        if (geocoded) {
                            // Usar coordenadas do geocoding
                            item.latitude = geocoded.latitude;
                            item.longitude = geocoded.longitude;
                            item.geocodedAddress = geocoded.displayName;
                            item.addressCleaned = cleanAddress(item.address);
                            successCount++;
                            console.log(`✅ [${globalIndex + 1}/${needsGeocoding.length}] ${item.addressCleaned}`);
                        } else {
                            console.error(`❌ [${globalIndex + 1}/${needsGeocoding.length}] Falha: ${item.address}`);
                            failedCount++;
                        }
                    } catch (error) {
                        console.error(`❌ [${globalIndex + 1}/${needsGeocoding.length}] Erro: ${item.address}`, error);
                        failedCount++;
                    }
                });

                // Aguardar conclusão do lote
                await Promise.all(promises);

                // Atualizar progresso
                const processed = Math.min(batchEnd, needsGeocoding.length);
                const totalProcessed = alreadyHasCoords.length + processed;
                const userInfo = state.currentUser ? ` [${state.currentUser.username}]` : '';
                statusElement.textContent = `Geocoding${userInfo}... ${totalProcessed}/${routeData.length} (✅ ${successCount} | ❌ ${failedCount} | 📋 ${usedFromSheet})`;

                // Delay mínimo entre lotes
                if (batchEnd < needsGeocoding.length) {
                    await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_BATCHES));
                }
            }

            console.log(`\n=== RESUMO DO GEOCODING ===`);
            console.log(`✅ ${successCount} endereços geocodificados com sucesso`);
            console.log(`📋 ${usedFromSheet} endereços usando coordenadas da planilha`);
            console.log(`❌ ${failedCount} endereços falharam completamente`);
            console.log(`📍 Total processado: ${routeData.length}`);

            if (successCount > 0) {
                showToast(`Geocoding concluído: ${successCount} novos, ${usedFromSheet} da planilha`, 'success');
            } else if (usedFromSheet > 0) {
                showToast(`Usando ${usedFromSheet} coordenadas da planilha`, 'info');
            }

            if (failedCount > 0) {
                showToast(`Atenção: ${failedCount} endereços não puderam ser localizados`, 'warning');
            }

            return; // Geocoding completo
        }

        // Upload Excel Spreadsheet
        const uploadBtn = document.getElementById('uploadBtn');
        const uploadInput = document.getElementById('uploadInput');
        const uploadStatus = document.getElementById('uploadStatus');

        uploadBtn.addEventListener('click', () => {
            uploadInput.click();
        });

        uploadInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Verificar se o usuário está logado
            if (!state.currentUser || !state.currentUser.id) {
                showToast('Erro: Usuário não autenticado', 'error');
                uploadStatus.textContent = '❌ Usuário não autenticado';
                uploadStatus.className = 'upload-status';
                uploadInput.value = '';
                return;
            }

            // Gerar ID único para esta sessão de upload
            const sessionId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            state.uploadSessionId = sessionId;

            uploadStatus.textContent = 'Processando planilha...';
            uploadStatus.className = 'upload-status';

            try {
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data);
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet);

                // Limpar base de dados anterior
                state.brDatabase = {};
                state.routeData = [];  // Limpar dados de rota anterior

                let count = 0;

                // Processar cada linha da planilha
                for (let i = 0; i < jsonData.length; i++) {
                    const row = jsonData[i];

                    // Procurar pelas colunas BR e Endereço (aceita vários formatos)
                    let brCode = null;
                    let address = null;

                    // Buscar coluna de código BR
                    if (row['SPX TN']) {
                        brCode = String(row['SPX TN']).trim();
                    } else if (row['BR']) {
                        brCode = String(row['BR']).trim();
                    } else if (row['Código BR']) {
                        brCode = String(row['Código BR']).trim();
                    } else if (row['Codigo BR']) {
                        brCode = String(row['Codigo BR']).trim();
                    } else if (row['Code']) {
                        brCode = String(row['Code']).trim();
                    }

                    // Buscar coluna de endereço
                    if (row['Destination Address']) {
                        address = String(row['Destination Address']).trim();
                    } else if (row['Endereço']) {
                        address = String(row['Endereço']).trim();
                    } else if (row['Endereco']) {
                        address = String(row['Endereco']).trim();
                    } else if (row['Address']) {
                        address = String(row['Address']).trim();
                    }

                    // Buscar latitude e longitude
                    let lat = row['Latitude'] || row['latitude'] || row['LAT'] || row['lat'];
                    let lng = row['Longitude'] || row['longitude'] || row['LNG'] || row['lng'] || row['LON'] || row['lon'];

                    // Se encontrou ambos, adicionar ao banco de dados
                    if (brCode && address && brCode !== 'undefined' && address !== 'undefined') {
                        state.brDatabase[brCode] = address;
                        count++;

                        // Usar coordenadas da planilha como fallback
                        // Se geocoding com IA estiver disponível, será substituído
                        state.routeData.push({
                            sequence: row['Sequence'] || i + 1,
                            stop: row['Stop'] || row['Parada'] || i + 1,
                            spxTn: brCode,
                            address: address,  // Endereço original completo (com referências)
                            addressOriginal: address,  // Guardar original
                            bairro: row['Bairro'] || row['Neighborhood'] || '',
                            city: row['City'] || row['Cidade'] || '',
                            zipcode: row['Zipcode/Postal code'] || row['CEP'] || '',
                            latitude: (lat && lng && !isNaN(lat)) ? parseFloat(lat) : null,
                            longitude: (lat && lng && !isNaN(lng)) ? parseFloat(lng) : null,
                            needsGeocoding: true
                        });
                    }
                }

                if (count > 0) {
                    // Fazer geocoding de todos os endereços (IGNORA coordenadas da planilha)
                    uploadStatus.textContent = 'Buscando coordenadas precisas dos endereços...';
                    await geocodeAllAddresses(state.routeData, uploadStatus, sessionId);

                    // Filtrar apenas endereços que foram geocodificados com sucesso
                    const validRouteData = state.routeData.filter(item =>
                        item.latitude !== null &&
                        item.latitude !== undefined &&
                        item.longitude !== null &&
                        item.longitude !== undefined
                    );

                    console.log(`📍 ${validRouteData.length} de ${state.routeData.length} endereços geocodificados com sucesso`);

                    if (validRouteData.length === 0) {
                        uploadStatus.textContent = '❌ Nenhum endereço pôde ser geocodificado';
                        uploadStatus.className = 'upload-status';
                        showToast('Erro: Não foi possível geocodificar nenhum endereço. Verifique sua conexão ou tente novamente.', 'error');
                        return;
                    }

                    // Cada endereço da planilha é uma parada individual
                    state.routeData = validRouteData.map(item => ({
                        ...item,
                        packages: [item.spxTn],
                        sequences: [item.sequence],
                        packageCount: 1
                    }));

                    // Salvar no Supabase
                    uploadStatus.textContent = 'Salvando no banco de dados...';
                    await saveBRDatabaseToSupabase(state.brDatabase);
                    await saveRouteDataToSupabase(state.routeData);

                    const totalPackages = state.routeData.reduce((sum, item) => sum + item.packageCount, 0);
                    uploadStatus.textContent = `✓ ${count} códigos BR carregados! ${state.routeData.length} endereços, ${totalPackages} pacotes.`;
                    uploadStatus.className = 'upload-status success';

                    console.log(`📊 Planilha processada e salva (user_id: ${state.currentUser.id}) - ISOLAMENTO ATIVO`);

                    // Mostrar botão de roteirização se tiver dados com coordenadas
                    if (state.routeData.length > 0) {
                        document.getElementById('optimizeRouteBtn').style.display = 'block';
                        console.log(`🗺️ ${state.routeData.length} endereços prontos para roteirização`);
                        console.log(`📦 Total de pacotes: ${totalPackages}`);
                    }
                } else {
                    uploadStatus.textContent = '⚠ Nenhum código encontrado';
                    uploadStatus.className = 'upload-status';
                    showToast('Nenhum código BR encontrado. Verifique se a planilha tem as colunas "SPX TN" e "Destination Address".', 'warning');
                }

                console.log('📊 Base de dados BR carregada:', state.brDatabase);
                console.log(`📊 Total de códigos: ${count}`);
                console.log('📍 Dados de rota agrupados:', state.routeData);

            } catch (error) {
                console.error('❌ Erro ao processar planilha:', error);
                console.error('Stack:', error.stack);
                uploadStatus.textContent = `❌ Erro: ${error.message}`;
                uploadStatus.className = 'upload-status';
                showToast(`Erro ao processar planilha: ${error.message}`, 'error');
            }

            // Limpar input
            uploadInput.value = '';
        });

        // AI Route Optimization
        const optimizeRouteBtn = document.getElementById('optimizeRouteBtn');
        const routeStatus = document.getElementById('routeStatus');

        optimizeRouteBtn.addEventListener('click', async () => {
            if (state.routeData.length === 0) {
                showToast('Nenhum dado de rota disponível. Faça upload de uma planilha primeiro.', 'warning');
                return;
            }

            // Parar navegação ativa antes de otimizar rota
            if (state.navigationActive) {
                console.log('⏹️ Parando navegação ativa antes de roteirizar');
                stopRealtimeNavigation();
            }

            routeStatus.textContent = '🤖 Processando roteirização...';
            routeStatus.className = 'upload-status';
            optimizeRouteBtn.disabled = true;

            try {
                // Usar algoritmo local (Nearest Neighbor) - rápido e sem necessidade de confirmação
                console.log('🔧 Roteirizando com algoritmo local');
                const optimizedOrder = optimizeRouteLocally(state.routeData);
                processOptimizedRoute(optimizedOrder);
                routeStatus.textContent = `✓ Rota otimizada! ${optimizedOrder.length} paradas.`;
                routeStatus.className = 'upload-status success';
                // showToast(`Rota otimizada com sucesso! ${optimizedOrder.length} paradas.`, 'success');
                optimizeRouteBtn.disabled = false;

                // FORÇAR remoção de qualquer overlay que possa estar ativo (problema no mobile)
                setTimeout(() => {
                    // Remover classe active de todos os overlays e modals
                    document.querySelectorAll('.modal-overlay, .processing-overlay, .sidebar-overlay').forEach(el => {
                        el.classList.remove('active');
                    });

                    // Garantir que nenhum elemento está bloqueando a interação
                    document.body.style.overflow = 'auto';
                    document.body.style.pointerEvents = 'auto';

                    // Remover qualquer elemento com z-index alto que possa estar bloqueando
                    const highZIndexElements = document.querySelectorAll('[style*="z-index"]');
                    highZIndexElements.forEach(el => {
                        const zIndex = parseInt(window.getComputedStyle(el).zIndex);
                        if (zIndex > 9000 && el.style.display !== 'none') {
                            console.log('⚠️ Elemento com z-index alto detectado:', el, 'z-index:', zIndex);
                        }
                    });

                    console.log('✅ Overlays limpos - interação restaurada');
                }, 100);

            } catch (error) {
                console.error('Erro ao iniciar roteirização:', error);
                routeStatus.textContent = '❌ Erro ao iniciar roteirização';
                routeStatus.className = 'upload-status';
                showToast('Erro ao iniciar roteirização: ' + error.message, 'error');
                optimizeRouteBtn.disabled = false;
            }
        });

        // Optimize Route with AI (Poe API)
        async function optimizeRouteWithAI() {
            // Preparar dados para enviar à IA
            const routeDataStr = JSON.stringify(state.routeData.map((stop, idx) => ({
                index: idx,
                stop: stop.stop,
                address: stop.address,
                city: stop.city,
                latitude: stop.latitude,
                longitude: stop.longitude
            })));

            // Registrar handler para receber resposta da IA
            window.Poe.registerHandler("route-optimizer", (result, context) => {
                const msg = result.responses[0];

                if (msg.status === "error") {
                    routeStatus.textContent = "❌ Erro na IA: " + msg.statusText;
                    routeStatus.className = 'upload-status';
                    optimizeRouteBtn.disabled = false;
                    showToast('Erro ao processar roteirização com IA', 'error');
                } else if (msg.status === "complete") {
                    try {
                        // Extrair JSON da resposta
                        const content = msg.content;
                        console.log('🤖 Resposta da IA:', content);

                        // Procurar por JSON na resposta (pode vir com texto explicativo)
                        const jsonMatch = content.match(/\[[\s\S]*\]/);
                        if (jsonMatch) {
                            const optimizedOrder = JSON.parse(jsonMatch[0]);
                            processOptimizedRoute(optimizedOrder);
                            routeStatus.textContent = `✓ Rota otimizada com IA! ${optimizedOrder.length} paradas.`;
                            routeStatus.className = 'upload-status success';
                            // showToast(`Rota otimizada com IA! ${optimizedOrder.length} paradas.`, 'success');
                        } else {
                            throw new Error('Resposta da IA não contém JSON válido');
                        }
                    } catch (error) {
                        console.error('Erro ao processar resposta da IA:', error);
                        routeStatus.textContent = '❌ Erro ao processar resposta';
                        routeStatus.className = 'upload-status';
                        showToast('Erro ao processar resposta da IA', 'error');
                    }
                    optimizeRouteBtn.disabled = false;
                }
            });

            // Chamar IA para otimizar rota
            const prompt = `Você é um especialista em otimização de rotas de entrega. Analise os seguintes endereços com suas coordenadas e retorne a ORDEM OTIMIZADA de paradas que minimiza a distância total percorrida.

DADOS DAS PARADAS:
${routeDataStr}

INSTRUÇÕES:
1. Use o algoritmo de vizinho mais próximo (Nearest Neighbor) ou similar para otimizar
2. Considere apenas as coordenadas (latitude/longitude) para calcular distâncias
3. Retorne APENAS um array JSON com os índices na ordem otimizada
4. Exemplo de resposta: [0, 5, 3, 1, 4, 2]
5. NÃO adicione explicações ou texto adicional, APENAS o array JSON

Retorne a ordem otimizada:`;

            try {
                await window.Poe.sendUserMessage(`@Claude-Sonnet-4.5 ${prompt}`, {
                    handler: "route-optimizer",
                    stream: false,
                    openChat: false
                });
            } catch (error) {
                // Tratar erros do Poe API (ex: usuário rejeitou confirmação)
                console.error('Erro ao enviar mensagem para Poe API:', error);

                if (error.errorType === 'USER_REJECTED_CONFIRMATION') {
                    routeStatus.textContent = '❌ Operação cancelada';
                    showToast('Roteirização cancelada pelo usuário', 'warning');
                } else {
                    routeStatus.textContent = '❌ Erro ao conectar com IA';
                    showToast('Erro ao conectar com IA: ' + error.message, 'error');
                }

                routeStatus.className = 'upload-status';
                optimizeRouteBtn.disabled = false;
                throw error; // Re-throw para o catch externo capturar
            }
        }

        // Optimize Route Locally (Nearest Neighbor Algorithm)
        function optimizeRouteLocally(routeData) {
            if (routeData.length === 0) return [];
            if (routeData.length === 1) return [0];

            // Função para calcular distância entre dois pontos (Haversine)
            function getDistance(lat1, lng1, lat2, lng2) {
                const R = 6371; // Raio da Terra em km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }

            // Usar posição atual como ponto de partida se disponível
            let currentLat, currentLng;
            if (state.currentLocation) {
                currentLat = state.currentLocation.lat;
                currentLng = state.currentLocation.lng;
            } else {
                // Usar primeira parada como ponto de partida
                currentLat = routeData[0].latitude;
                currentLng = routeData[0].longitude;
            }

            const unvisited = new Set(routeData.map((_, idx) => idx));
            const route = [];

            // Algoritmo do vizinho mais próximo
            while (unvisited.size > 0) {
                let nearestIndex = -1;
                let nearestDistance = Infinity;

                // Encontrar o ponto não visitado mais próximo
                for (const idx of unvisited) {
                    const stop = routeData[idx];
                    const distance = getDistance(
                        currentLat, currentLng,
                        stop.latitude, stop.longitude
                    );

                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestIndex = idx;
                    }
                }

                // Adicionar à rota e marcar como visitado
                route.push(nearestIndex);
                unvisited.delete(nearestIndex);

                // Atualizar posição atual
                currentLat = routeData[nearestIndex].latitude;
                currentLng = routeData[nearestIndex].longitude;
            }

            console.log('🗺️ Rota otimizada localmente:', route);
            return route;
        }

        // ========== SISTEMA DE ROTEAMENTO PROFISSIONAL (ESTILO CIRCUIT) ==========

        // Cache de rotas para evitar recalcular
        const routeCache = new Map();

        // Decodificar polyline codificada (formato usado por Google Maps e OSRM)
        function decodePolyline(encoded) {
            if (!encoded) return [];

            const poly = [];
            let index = 0, len = encoded.length;
            let lat = 0, lng = 0;

            while (index < len) {
                let b, shift = 0, result = 0;
                do {
                    b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (b >= 0x20);
                const dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
                lat += dlat;

                shift = 0;
                result = 0;
                do {
                    b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (b >= 0x20);
                const dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
                lng += dlng;

                poly.push([lat / 1e5, lng / 1e5]);
            }
            return poly;
        }

        // Gerar chave única para cache de rota
        function getRouteCacheKey(lat1, lng1, lat2, lng2) {
            return `${lat1.toFixed(5)},${lng1.toFixed(5)}-${lat2.toFixed(5)},${lng2.toFixed(5)}`;
        }

        // Função auxiliar para aguardar um delay
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // API Google Maps Directions (MELHOR - Requer API Key)
        async function fetchFromGoogleMaps(startLat, startLng, endLat, endLng, timeout = 10000) {
            // Verificar se tem API Key configurada
            if (!state.googleMapsApiKey) {
                console.log('Google Maps: Sem API Key configurada');
                return null;
            }

            // Usar proxy CORS para evitar bloqueio
            const apiUrl = `https://maps.googleapis.com/maps/api/directions/json?origin=${startLat},${startLng}&destination=${endLat},${endLng}&mode=driving&language=pt-BR&key=${state.googleMapsApiKey}`;
            const url = `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl)}`;

            console.log('🗺️ Google Maps: Testando rota...');

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    console.warn(`Google Maps HTTP ${response.status}`);
                    return null;
                }

                const data = await response.json();
                console.log('Google Maps resposta:', data);

                if (data.status === 'OK' && data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    const leg = route.legs[0];
                    const coords = decodePolyline(route.overview_polyline.points);

                    if (coords && coords.length > 1) {
                        console.log(`✅ Google Maps: Rota OK (${(leg.distance.value/1000).toFixed(1)}km)`);
                        return {
                            coordinates: coords,
                            distance: leg.distance.value, // metros
                            duration: leg.duration.value, // segundos
                            source: 'Google Maps'
                        };
                    }
                } else if (data.status) {
                    console.warn(`Google Maps status: ${data.status}`, data.error_message || '');
                }
                return null;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name !== 'AbortError') {
                    console.error('Google Maps erro:', error.message);
                }
                return null;
            }
        }

        // Buscar rota usando APENAS Google Maps Platform API
        async function fetchRouteFromMultipleAPIs(startLat, startLng, endLat, endLng, maxRetries = 3) {
            // Verificar cache primeiro
            const cacheKey = getRouteCacheKey(startLat, startLng, endLat, endLng);
            if (routeCache.has(cacheKey)) {
                return routeCache.get(cacheKey);
            }

            // Verificar se tem API Key configurada
            if (!state.googleMapsApiKey) {
                console.error('❌ Google Maps API Key não configurada! Configure em "⚙️ Config"');
                return null;
            }

            // Tentar até maxRetries vezes
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const result = await fetchFromGoogleMaps(startLat, startLng, endLat, endLng);

                    if (result && result.coordinates && result.coordinates.length > 1) {
                        console.log(`✅ Google Maps OK (tentativa ${attempt})`);
                        // Salvar no cache
                        routeCache.set(cacheKey, result);
                        return result;
                    } else {
                        console.warn(`⚠️ Google Maps retornou vazio (tentativa ${attempt})`);
                    }
                } catch (error) {
                    console.warn(`⚠️ Google Maps erro (tentativa ${attempt}):`, error.message);
                }

                // Aguardar antes de próxima tentativa (apenas se não for a última)
                if (attempt < maxRetries) {
                    const delayMs = 2000 * attempt; // 2s, 4s, 6s
                    console.log(`⏳ Aguardando ${delayMs}ms antes de retry...`);
                    await delay(delayMs);
                }
            }

            // Se chegou aqui, todas as tentativas falharam
            console.error(`❌ Google Maps: Não foi possível obter rota após ${maxRetries} tentativas`);
            return null;
        }

        // Desenhar rotas reais entre todas as paradas (PROCESSAMENTO EM LOTES - MAIS ESTÁVEL)
        async function drawRealRoutes(optimizedOrder, colors, isMobile) {
            console.log('🗺️ Buscando rotas reais baseadas em estradas...');

            const routeStatus = document.getElementById('routeStatus');
            if (routeStatus) {
                routeStatus.textContent = '🗺️ Calculando rotas reais...';
            }

            let totalDistance = 0;
            let totalDuration = 0;
            let routesDrawn = 0;
            let routesFailed = 0;

            const totalRoutes = optimizedOrder.length - 1;
            const BATCH_SIZE = 10; // Processar 10 rotas por vez para não sobrecarregar APIs
            const routeColor = '#3b82f6'; // Cor fixa azul para todas as rotas

            // Processar rotas em lotes
            for (let batchStart = 0; batchStart < totalRoutes; batchStart += BATCH_SIZE) {
                const batchEnd = Math.min(batchStart + BATCH_SIZE, totalRoutes);
                const batchPromises = [];

                console.log(`📦 Processando lote ${Math.floor(batchStart / BATCH_SIZE) + 1}/${Math.ceil(totalRoutes / BATCH_SIZE)} (rotas ${batchStart + 1}-${batchEnd})`);

                // Criar promises para este lote
                for (let j = batchStart; j < batchEnd; j++) {
                    const currentStop = state.routeData[optimizedOrder[j]];
                    const nextStop = state.routeData[optimizedOrder[j + 1]];
                    const routeIndex = j;

                    const routePromise = fetchRouteFromMultipleAPIs(
                        currentStop.latitude,
                        currentStop.longitude,
                        nextStop.latitude,
                        nextStop.longitude
                    ).then(routeData => {
                        if (routeData && routeData.coordinates && routeData.coordinates.length > 1) {
                            // ✅ SUCESSO: Desenhar rota real
                            const polyline = L.polyline(routeData.coordinates, {
                                color: routeColor,
                                weight: isMobile ? 4 : 5,
                                opacity: 0.8,
                                smoothFactor: 1
                            }).addTo(state.map);

                            state.routePolylines.push(polyline);
                            totalDistance += routeData.distance;
                            totalDuration += routeData.duration;
                            routesDrawn++;

                            // Atualizar progresso
                            const progress = Math.round(((routesDrawn + routesFailed) / totalRoutes) * 100);
                            if (routeStatus) {
                                routeStatus.textContent = `🗺️ ${routesDrawn}/${totalRoutes} rotas • ${progress}%`;
                            }

                            return { success: true, routeIndex };
                        } else {
                            // ❌ FALHA: Não desenhar linha reta
                            console.warn(`⚠️ Rota ${routeIndex + 1}→${routeIndex + 2} falhou`);
                            routesFailed++;

                            const progress = Math.round(((routesDrawn + routesFailed) / totalRoutes) * 100);
                            if (routeStatus) {
                                routeStatus.textContent = `⚠️ ${routesDrawn}/${totalRoutes} rotas • ${routesFailed} falhas • ${progress}%`;
                            }

                            return { success: false, routeIndex };
                        }
                    }).catch(error => {
                        console.error(`❌ Erro rota ${routeIndex + 1}:`, error.message);
                        routesFailed++;

                        const progress = Math.round(((routesDrawn + routesFailed) / totalRoutes) * 100);
                        if (routeStatus) {
                            routeStatus.textContent = `⚠️ ${routesDrawn}/${totalRoutes} rotas • ${routesFailed} falhas • ${progress}%`;
                        }

                        return { success: false, routeIndex, error };
                    });

                    batchPromises.push(routePromise);
                }

                // Aguardar este lote completar antes de prosseguir
                await Promise.all(batchPromises);

                // Pequeno delay entre lotes para não sobrecarregar as APIs
                if (batchEnd < totalRoutes) {
                    await delay(500);
                }
            }

            // Resultados finais
            const results = [];

            // Mostrar estatísticas da rota
            const distanceKm = (totalDistance / 1000).toFixed(1);
            const durationMin = Math.round(totalDuration / 60);
            const successRate = Math.round((routesDrawn / totalRoutes) * 100);

            console.log(`✅ Rotas processadas! ${routesDrawn} rotas reais desenhadas | ${routesFailed} falhas | Taxa sucesso: ${successRate}%`);
            console.log(`📊 Distância total: ${distanceKm}km | Duração estimada: ${durationMin}min`);

            if (routeStatus) {
                if (routesDrawn === totalRoutes) {
                    // 100% de sucesso
                    routeStatus.textContent = `✓ Rota: ${optimizedOrder.length} paradas • ${distanceKm}km • ~${durationMin}min`;
                    routeStatus.className = 'upload-status success';
                } else if (routesDrawn > 0) {
                    // Sucesso parcial
                    routeStatus.textContent = `⚠️ ${routesDrawn}/${totalRoutes} rotas reais • ${routesFailed} falhas`;
                    routeStatus.className = 'upload-status warning';
                } else {
                    // Falha total
                    routeStatus.textContent = `❌ Não foi possível obter rotas reais`;
                    routeStatus.className = 'upload-status error';
                }
            }

            // Se houve falhas, mostrar alerta ao usuário
            if (routesFailed > 0) {
                const failedRoutes = results.filter(r => !r.success).map(r => r.routeIndex + 1);
                console.warn(`⚠️ Rotas que falharam: ${failedRoutes.join(', ')}`);
                showToast(`Aviso: ${routesFailed} de ${totalRoutes} rotas não puderam ser calculadas. Verifique sua conexão.`, 'warning');
            }
        }

        // Process Optimized Route from AI
        async function processOptimizedRoute(optimizedOrder) {
            // Ativar modo de visualização de rota otimizada
            state.viewingOptimizedRoute = true;

            // Armazenar ordem otimizada no estado
            state.optimizedOrder = optimizedOrder;

            // Salvar rota otimizada no Supabase
            saveOptimizedRouteToSupabase(optimizedOrder);

            // Fechar TODOS os popups, incluindo o "Você está aqui"
            state.map.closePopup();
            if (state.currentLocationMarker) {
                state.currentLocationMarker.closePopup();
            }

            // Limpar marcadores e polylines anteriores da rota otimizada
            state.routePolylines.forEach(polyline => state.map.removeLayer(polyline));
            state.routePolylines = [];

            // Detectar se é mobile para otimizações
            const isMobile = window.innerWidth <= 768;

            // Usar cor fixa azul para todas as paradas
            const fixedColor = '#3b82f6'; // Azul

            // Decidir tipo de marcador: ícones bonitos para poucas paradas, simples para muitas
            const totalStops = optimizedOrder.length;
            const usePrettyIcons = !isMobile || totalStops <= 10;  // Reduzido de 20 para 10

            console.log(`🎨 Renderizando ${totalStops} paradas - Modo: ${isMobile ? 'MOBILE' : 'DESKTOP'} - Ícones: ${usePrettyIcons ? 'BONITOS ✨' : 'SIMPLES ⚡'}`);

            // Detectar e deslocar marcadores sobrepostos
            const offsetMap = new Map(); // Mapa para rastrear deslocamentos
            const OVERLAP_THRESHOLD = 0.00005; // ~5 metros (ajustável)
            const OFFSET_AMOUNT = 0.0001; // ~11 metros de deslocamento

            function getAdjustedCoordinates(lat, lng, index) {
                let adjustedLat = lat;
                let adjustedLng = lng;

                // Verificar se há marcadores muito próximos já adicionados
                for (const [key, offset] of offsetMap.entries()) {
                    const [existingLat, existingLng] = key.split('_').map(Number);
                    const latDiff = Math.abs(existingLat - adjustedLat);
                    const lngDiff = Math.abs(existingLng - adjustedLng);

                    // Se estiver muito próximo, aplicar offset
                    if (latDiff < OVERLAP_THRESHOLD && lngDiff < OVERLAP_THRESHOLD) {
                        // Aplicar deslocamento em círculo baseado no número de offsets já aplicados
                        const angle = (offset.count * 60) * (Math.PI / 180); // 60 graus entre cada marcador
                        adjustedLat = existingLat + (OFFSET_AMOUNT * Math.cos(angle));
                        adjustedLng = existingLng + (OFFSET_AMOUNT * Math.sin(angle));
                        offset.count++;
                        console.log(`📍 Marcador ${index + 1} deslocado para evitar sobreposição`);
                        break;
                    }
                }

                // Registrar a posição ajustada
                const key = `${adjustedLat}_${adjustedLng}`;
                if (!offsetMap.has(key)) {
                    offsetMap.set(key, { count: 1 });
                }

                return [adjustedLat, adjustedLng];
            }

            optimizedOrder.forEach((originalIndex, routeIndex) => {
                const stop = state.routeData[originalIndex];
                if (!stop) return;

                // Obter coordenadas ajustadas para evitar sobreposição
                const [adjustedLat, adjustedLng] = getAdjustedCoordinates(
                    stop.latitude,
                    stop.longitude,
                    routeIndex
                );

                const stopNumber = routeIndex + 1;
                const isDelivered = state.deliveredStops.has(routeIndex);
                const color = isDelivered ? '#9ca3af' : fixedColor; // Cinza se entregue, azul se não
                const packageCount = stop.packageCount || 1;

                // Mobile com MUITAS paradas: usar CircleMarker simples (máxima performance)
                if (isMobile && !usePrettyIcons) {
                    const circleMarker = L.circleMarker([adjustedLat, adjustedLng], {
                        radius: 12,
                        fillColor: color,
                        color: '#fff',
                        weight: 2,
                        opacity: isDelivered ? 0.6 : 1,
                        fillOpacity: isDelivered ? 0.5 : 0.9
                    }).addTo(state.map);

                    // Popup lazy-loaded com info de pacotes e botão de navegação
                    // CORREÇÃO: Não usar .openPopup() dentro do click handler - o Leaflet já abre o popup automaticamente
                    const createPopupContent = () => {
                        const sequencesList = stop.sequences && stop.sequences.length > 0
                            ? stop.sequences.sort((a, b) => a - b).join(', ')
                            : '-';
                        const currentlyDelivered = state.deliveredStops.has(routeIndex);

                        return `
                            <div style="font-size: 13px; min-width: 200px;">
                                <div style="font-weight: bold; margin-bottom: 6px; color: ${color};">
                                    ${currentlyDelivered ? '✅' : '🚚'} Parada ${stopNumber} • ${packageCount} pacote${packageCount > 1 ? 's' : ''}
                                </div>
                                <div style="margin: 3px 0;">📍 ${stop.address}</div>
                                <div style="margin: 3px 0; font-size: 11px; color: #666;">Ordem: ${sequencesList}</div>
                                ${!currentlyDelivered ? `
                                    <button onclick="markStopAsDelivered(${routeIndex}, ${JSON.stringify(stop).replace(/"/g, '&quot;')})"
                                        style="margin-top: 8px; width: 100%; padding: 8px; background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">
                                        ✅ Marcar como entregue
                                    </button>
                                ` : `
                                    <button onclick="unmarkStopAsDelivered(${routeIndex})"
                                        style="margin-top: 8px; width: 100%; padding: 8px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">
                                        ↩️ Desfazer entrega
                                    </button>
                                `}
                                <button onclick="startNavigationToStop(${stop.latitude}, ${stop.longitude}, '${stop.address.replace(/'/g, "\\'")}', ${stopNumber})"
                                    style="margin-top: 6px; width: 100%; padding: 8px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px;">
                                    🧭 Navegar até aqui
                                </button>
                            </div>
                        `;
                    };

                    // Bind popup inicial
                    circleMarker.bindPopup(createPopupContent());

                    // Atualizar conteúdo do popup quando aberto (para refletir mudanças de status)
                    circleMarker.on('click', function() {
                        this.setPopupContent(createPopupContent());
                    });

                    state.routePolylines.push(circleMarker);
                    return; // Pula resto do código
                }

                // PINO DE GPS com numeração de pacotes no topo (Desktop OU Mobile com poucas paradas)
                // CSS simplificado para mobile: menos sombras e bordas
                const iconHTML = `
                    <div style="position: relative; width: 40px; height: ${packageCount > 1 ? '55px' : '40px'};">
                        ${packageCount > 1 ? `
                            <div style="
                                position: absolute;
                                top: -10px;
                                left: 50%;
                                transform: translateX(-50%);
                                background: #ef4444;
                                color: white;
                                border-radius: ${isMobile ? '8px' : '12px'};
                                padding: 2px ${isMobile ? '6px' : '8px'};
                                font-size: ${isMobile ? '10px' : '11px'};
                                font-weight: bold;
                                border: ${isMobile ? '1px' : '2px'} solid white;
                                box-shadow: ${isMobile ? '0 1px 3px rgba(0,0,0,0.3)' : '0 2px 6px rgba(0,0,0,0.3)'};
                                white-space: nowrap;
                                z-index: 10;
                            ">
                                ${packageCount} pacote${packageCount > 1 ? 's' : ''}
                            </div>
                        ` : ''}
                        <div style="
                            position: relative;
                            width: ${isMobile ? '32px' : '36px'};
                            height: ${isMobile ? '32px' : '36px'};
                            background: ${color};
                            border-radius: 50% 50% 50% 0;
                            border: ${isMobile ? '2px' : '3px'} solid white;
                            box-shadow: ${isMobile ? '0 2px 5px rgba(0,0,0,0.35)' : '0 3px 8px rgba(0,0,0,0.4)'};
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transform: rotate(-45deg);
                            margin: ${packageCount > 1 ? '18px' : '0'} auto 0 auto;
                        ">
                            <div style="
                                transform: rotate(45deg);
                                color: white;
                                font-weight: bold;
                                font-size: ${isMobile ? '13px' : '16px'};
                            ">
                                ${stopNumber}
                            </div>
                        </div>
                    </div>
                `;

                const numberedIcon = L.divIcon({
                    className: 'numbered-marker',
                    html: iconHTML,
                    iconSize: packageCount > 1 ? [40, 55] : [40, 40],
                    iconAnchor: packageCount > 1 ? [20, 55] : [20, 40]
                });

                // Adicionar marcador com coordenadas ajustadas
                const marker = L.marker([adjustedLat, adjustedLng], {
                    icon: numberedIcon,
                    title: `Parada ${stopNumber}: ${stop.address}`
                }).addTo(state.map);

                // Preparar lista completa de sequences (sem abreviação)
                const sequencesList = stop.sequences && stop.sequences.length > 0
                    ? stop.sequences.sort((a, b) => a - b).join(', ')
                    : stop.sequence || '-';

                // Preparar lista de pacotes (mais limitada para mobile)
                const packagesList = stop.packages && stop.packages.length > 0
                    ? (stop.packages.length <= (isMobile ? 5 : 10)
                        ? stop.packages.join(', ')
                        : `${stop.packages.slice(0, isMobile ? 5 : 10).join(', ')}... (+${stop.packages.length - (isMobile ? 5 : 10)})`)
                    : stop.spxTn || '-';

                // Calcular distância e tempo da localização atual até esta parada
                let distanceInfo = '';
                if (state.currentLocationMarker) {
                    const currentPos = state.currentLocationMarker.getLatLng();
                    const distKm = calculateDistance(currentPos.lat, currentPos.lng, stop.latitude, stop.longitude);
                    const estTime = calculateEstimatedTime(distKm);
                    distanceInfo = `<p style="margin: 4px 0; padding: 6px; background: #eff6ff; border-radius: 4px; font-size: ${isMobile ? '11px' : '12px'};"><strong>🚗 Distância:</strong> ${formatDistance(distKm)} · <strong>⏱️</strong> ${estTime}</p>`;
                }

                // Popup simplificado para mobile
                const popupContent = isMobile ? `
                    <div class="popup-content" style="max-width: 250px;">
                        <h3 style="margin: 0 0 8px 0; font-size: 16px;">${isDelivered ? '✅' : '🚚'} Parada ${stopNumber}</h3>
                        ${distanceInfo}
                        <p style="margin: 4px 0;"><strong>📦 Pacotes:</strong> ${packageCount}</p>
                        <p style="margin: 4px 0;"><strong>🔢 Ordem:</strong> ${sequencesList}</p>
                        <p style="margin: 4px 0;"><strong>📍</strong> ${stop.address}</p>
                        ${stop.city ? `<p style="margin: 4px 0; font-size: 12px;"><strong>🏙️</strong> ${stop.city}</p>` : ''}
                        ${!isDelivered ? `
                            <button onclick="markStopAsDelivered(${routeIndex}, ${JSON.stringify(stop).replace(/"/g, '&quot;')})"
                                style="margin-top: 10px; width: 100%; padding: 10px; background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 13px;">
                                ✅ Marcar como entregue
                            </button>
                        ` : `
                            <button onclick="unmarkStopAsDelivered(${routeIndex})"
                                style="margin-top: 10px; width: 100%; padding: 10px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 13px;">
                                ↩️ Desfazer entrega
                            </button>
                        `}
                        <button onclick="startNavigationToStop(${stop.latitude}, ${stop.longitude}, '${stop.address.replace(/'/g, "\\'")}', ${stopNumber})"
                            style="margin-top: 6px; width: 100%; padding: 10px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 13px;">
                            🧭 Navegar até aqui
                        </button>
                    </div>
                ` : `
                    <div class="popup-content">
                        <h3>${isDelivered ? '✅' : '🚚'} Parada ${stopNumber}</h3>
                        ${distanceInfo}
                        <p><strong>📦 Pacotes:</strong> ${packageCount}</p>
                        <p><strong>🔢 Ordem:</strong><br><span style="font-size: 12px; color: #666;">${sequencesList}</span></p>
                        <p><strong>📍 Endereço:</strong><br>${stop.address}</p>
                        <p><strong>🏙️ Cidade:</strong> ${stop.city}</p>
                        <p><strong>📮 CEP:</strong> ${stop.zipcode}</p>
                        <p><strong>📦 Códigos SPX:</strong><br><span style="font-size: 11px; color: #666;">${packagesList}</span></p>
                        ${!isDelivered ? `
                            <button onclick="markStopAsDelivered(${routeIndex}, ${JSON.stringify(stop).replace(/"/g, '&quot;')})"
                                style="margin-top: 12px; width: 100%; padding: 10px; background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                ✅ Marcar como entregue
                            </button>
                        ` : `
                            <button onclick="unmarkStopAsDelivered(${routeIndex})"
                                style="margin-top: 12px; width: 100%; padding: 10px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                ↩️ Desfazer entrega
                            </button>
                        `}
                        <button onclick="startNavigationToStop(${stop.latitude}, ${stop.longitude}, '${stop.address.replace(/'/g, "\\'")}', ${stopNumber})"
                            style="margin-top: 8px; width: 100%; padding: 10px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            🧭 Navegar até aqui
                        </button>
                    </div>
                `;

                marker.bindPopup(popupContent);

                // Armazenar para limpar depois
                state.routePolylines.push(marker);

                // NOTA: As rotas reais serão desenhadas depois com drawRealRoutes()
                // Não desenhar linhas retas aqui
            });

            // Ajustar zoom e centralizar mapa para mostrar toda a rota
            if (optimizedOrder.length > 0) {
                const bounds = L.latLngBounds(
                    optimizedOrder.map(idx => [state.routeData[idx].latitude, state.routeData[idx].longitude])
                );

                // Ajustar mapa com delay para garantir que todos os marcadores foram renderizados
                setTimeout(() => {
                    console.log('📍 Ajustando visualização para mostrar rota otimizada');
                    state.map.fitBounds(bounds, {
                        padding: isMobile ? [50, 50] : [100, 100],
                        maxZoom: isMobile ? 16 : 17,
                        animate: true,
                        duration: 1.0
                    });
                }, 600);  // Delay para garantir que stopRealtimeNavigation completou
            }

            // Armazenar rota otimizada
            state.optimizedRoute = optimizedOrder;

            // Atualizar contador de entregas
            updateDeliveryCounter();

            // Desenhar rotas reais usando dados do Google Maps/OSRM
            await drawRealRoutes(optimizedOrder, colors, isMobile);

            // Fechar aba lateral em mobile para melhor visualização
            const sidebar = document.querySelector('.sidebar');
            const sidebarOverlay = document.getElementById('sidebarOverlay');
            if (sidebar && sidebar.classList.contains('open') && window.innerWidth <= 768) {
                sidebar.classList.remove('open');
                // CORREÇÃO: Remover também o overlay da sidebar quando fechar
                if (sidebarOverlay) {
                    sidebarOverlay.classList.remove('active');
                }
                // CORREÇÃO CRÍTICA: Restaurar overflow do body (estava bloqueando interação)
                document.body.style.overflow = '';
                // Restaurar banner de Admin/Sair
                const userHeaderInfo = document.getElementById('userHeaderInfo');
                if (userHeaderInfo) {
                    userHeaderInfo.style.opacity = '1';
                    userHeaderInfo.style.pointerEvents = 'auto';
                }
            }

            console.log('✅ Rota otimizada processada e exibida no mapa');
            console.log(`📍 Visualizando ${optimizedOrder.length} paradas no mapa`);
        }

        // Initialize App
        (async () => {
            const hasSession = await checkSession();
            if (!hasSession) {
                // Mostrar tela de login
                document.getElementById('loginContainer').classList.remove('hidden');
                hideLoading();
            } else {
                // Usuário já logado, iniciar app
                getCurrentLocation();
            }
        })();
    </script>
</body>
</html>
